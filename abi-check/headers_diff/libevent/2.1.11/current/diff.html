<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="Libevent, header, diff" />
    <meta name="description" content="Diff for header files between 2.1.11 and current versions of libevent" />
    <link rel="stylesheet" type="text/css" href="../../../../css/common.css?v=1.3" />
    <link rel="stylesheet" type="text/css" href="../../../../css/headers_diff.css?v=1.1.1" />
    
    <title>
        Libevent: headers diff between 2.1.11 and current versions
    </title>
    
    </head>

<body>
<table width='100%' cellpadding='0' cellspacing='0'><tr><td><table cellpadding='0' cellspacing='0'>
<tr><td align='center'><h1 class='tool'><a title='ABI tracker for Libevent' href='../../../../timeline/libevent/index.html' class='tool'>ABI<br/>Tracker</a></h1></td><td width='30px;'></td><td><h1>(Libevent)</h1></td></tr>
</table>
<hr/>
<br/>
<br/>
<h1>Headers diff: <span class='version'>2.1.11</span> vs <span class='version'>current</span></h1><br/><br/> 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;buffer.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;buffer.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFER_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFER_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFER_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFER_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/buffer.h</td><td> </td><td class="right">/** @file event2/buffer.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Functions for buffering data for network sending or receiving.</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Functions for buffering data for network sending or receiving.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  An evbuffer can be used for preparing data before sending it to</td><td> </td><td class="right">  An evbuffer can be used for preparing data before sending it to</td></tr>
      <tr><td class="left">  the network or conversely for reading data from the network.</td><td> </td><td class="right">  the network or conversely for reading data from the network.</td></tr>
      <tr><td class="left">  Evbuffers try to avoid memory copies as much as possible.  As a</td><td> </td><td class="right">  Evbuffers try to avoid memory copies as much as possible.  As a</td></tr>
      <tr><td class="left">  result, evbuffers can be used to pass data around without actually</td><td> </td><td class="right">  result, evbuffers can be used to pass data around without actually</td></tr>
      <tr><td class="left">  incurring the overhead of copying the data.</td><td> </td><td class="right">  incurring the overhead of copying the data.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  A new evbuffer can be allocated with evbuffer_new(), and can be</td><td> </td><td class="right">  A new evbuffer can be allocated with evbuffer_new(), and can be</td></tr>
      <tr><td class="left">  freed with evbuffer_free().  Most users will be using evbuffers via</td><td> </td><td class="right">  freed with evbuffer_free().  Most users will be using evbuffers via</td></tr>
      <tr><td class="left">  the bufferevent interface.  To access a bufferevent's evbuffers, use</td><td> </td><td class="right">  the bufferevent interface.  To access a bufferevent's evbuffers, use</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 162<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 162<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">struct evbuffer *evbuffer_new(void);</td><td> </td><td class="right">struct evbuffer *evbuffer_new(void);</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Deallocate storage for an evbuffer.</td><td> </td><td class="right">  Deallocate storage for an evbuffer.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param buf pointer to the evbuffer to be freed</td><td> </td><td class="right">  @param buf pointer to the evbuffer to be freed</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evbuffer_free(struct evbuffer *buf);</td><td> </td><td class="right">void evbuffer_free(struct evbuffer *buf);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">Set maximum read buffer size</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Default is 4096 and it works fine most of time, so before increasing the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  default check carefully, since this has some negative effects (like memor</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  fragmentation and unfair resource distribution, i.e. some events will mak</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  less progress than others).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param buf pointer to the evbuffer</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param max buffer size</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @return 0 on success, -1 on failure (if max &gt; INT_MAX).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evbuffer_set_max_read(struct evbuffer *buf, size_t max);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Get maximum read buffer size</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param buf pointer to the evbuffer</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @return current maximum buffer read</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">size_t evbuffer_get_max_read(struct evbuffer *buf);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left">   Enable locking on an evbuffer so that it can safely be used by multiple</td><td> </td><td class="right">   Enable locking on an evbuffer so that it can safely be used by multiple</td></tr>
      <tr><td class="left">   threads at the same time.</td><td> </td><td class="right">   threads at the same time.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   NOTE: when locking is enabled, the lock will be held when callbacks are</td><td> </td><td class="right">   NOTE: when locking is enabled, the lock will be held when callbacks are</td></tr>
      <tr><td class="left">   invoked.  This could result in deadlock if you aren't careful.  Plan</td><td> </td><td class="right">   invoked.  This could result in deadlock if you aren't careful.  Plan</td></tr>
      <tr><td class="left">   accordingly!</td><td> </td><td class="right">   accordingly!</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param buf An evbuffer to make lockable.</td><td> </td><td class="right">   @param buf An evbuffer to make lockable.</td></tr>
      <tr><td class="left">   @param lock A lock object, or NULL if we should allocate our own.</td><td> </td><td class="right">   @param lock A lock object, or NULL if we should allocate our own.</td></tr>
      <tr><td class="left">   @return 0 on success, -1 on failure.</td><td> </td><td class="right">   @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 209<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 232<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * information.</td><td> </td><td class="right"> * information.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This flag is on by default for bufferevents that can take advantage</td><td> </td><td class="right"> * This flag is on by default for bufferevents that can take advantage</td></tr>
      <tr><td class="left"> * of it; you should never actually need to set it on a bufferevent's</td><td> </td><td class="right"> * of it; you should never actually need to set it on a bufferevent's</td></tr>
      <tr><td class="left"> * output buffer.</td><td> </td><td class="right"> * output buffer.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVBUFFER_FLAG_DRAINS_TO_FD 1</td><td> </td><td class="right">#define EVBUFFER_FLAG_DRAINS_TO_FD 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Change the flags that are set for an evbuffer by adding more.</td><td> </td><td class="right">/** Change the flags that are set for an evbuffer by adding more.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"> * @param <span class="delete">buffer</span> the evbuffer that the callback is watching.</td><td> </td><td class="rblock"> * @param <span class="insert">buf</span> the evbuffer that the callback is watching.</td></tr>
      <tr><td class="lblock"> <span class="delete">* @param cb the callback whose status we want to change.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> * @param flags One or more EVBUFFER_FLAG_* options</td><td> </td><td class="right"> * @param flags One or more EVBUFFER_FLAG_* options</td></tr>
      <tr><td class="left"> * @return 0 on success, -1 on failure.</td><td> </td><td class="right"> * @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags);</td><td> </td><td class="right">int evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags);</td></tr>
      <tr><td class="left">/** Change the flags that are set for an evbuffer by removing some.</td><td> </td><td class="right">/** Change the flags that are set for an evbuffer by removing some.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"> * @param <span class="delete">buffer</span> the evbuffer that the callback is watching.</td><td> </td><td class="rblock"> * @param <span class="insert">buf</span> the evbuffer that the callback is watching.</td></tr>
      <tr><td class="lblock"> <span class="delete">* @param cb the callback whose status we want to change.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> * @param flags One or more EVBUFFER_FLAG_* options</td><td> </td><td class="right"> * @param flags One or more EVBUFFER_FLAG_* options</td></tr>
      <tr><td class="left"> * @return 0 on success, -1 on failure.</td><td> </td><td class="right"> * @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags);</td><td> </td><td class="right">int evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Returns the total number of bytes stored in the evbuffer</td><td> </td><td class="right">  Returns the total number of bytes stored in the evbuffer</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param buf pointer to the evbuffer</td><td> </td><td class="right">  @param buf pointer to the evbuffer</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 4 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>5 lines changed or deleted</i></th><th><i> </i></th><th><i>28 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;buffer_compat.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;buffer_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 34<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 34<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFER_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFER_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFER_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFER_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/buffer_compat.h</td><td> </td><td class="right">/** @file event2/buffer_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">       <span class="delete">Obsolete and deprecated versions of the functions in buffer.h: provi
</span>ded</td><td> </td><td class="rblock">       <span class="insert">@brief Obsolete and deprecated versions of the functions in buffer.h
: provi</span>ded</td></tr>
      <tr><td class="left">       only for backward compatibility.</td><td> </td><td class="right">       only for backward compatibility.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Obsolete alias for evbuffer_readln(buffer, NULL, EVBUFFER_EOL_ANY).</td><td> </td><td class="right">   Obsolete alias for evbuffer_readln(buffer, NULL, EVBUFFER_EOL_ANY).</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @deprecated This function is deprecated because its behavior is not corr
ect</td><td> </td><td class="right">   @deprecated This function is deprecated because its behavior is not corr
ect</td></tr>
      <tr><td class="left">      for almost any protocol, and also because it's wholly subsumed by</td><td> </td><td class="right">      for almost any protocol, and also because it's wholly subsumed by</td></tr>
      <tr><td class="left">      evbuffer_readln().</td><td> </td><td class="right">      evbuffer_readln().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;bufferevent.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;bufferevent.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 33<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 33<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFEREVENT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFEREVENT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFEREVENT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFEREVENT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   @file event2/bufferevent.h</td><td> </td><td class="right">   @file event2/bufferevent.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Functions for buffering data for network sending or receiving.  <span class="delete">Buffereve</span></td><td> </td><td class="rblock">  <span class="insert">@brief</span> Functions for buffering data for network sending or receiving.</td></tr>
      <tr><td class="lblock"><span class="delete">nts</span></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock">  are higher level than evbuffers: each has an underlying <span class="delete">evbuffer</span> for <span class="delete">read</span></td><td> </td><td class="rblock">  <span class="insert">Bufferevents</span> are higher level than evbuffers: each has an underlying <span class="insert">evbu</span></td></tr>
      <tr><td class="lblock"><span class="delete">ing</span></td><td> </td><td class="rblock"><span class="insert">ffer</span> for <span class="insert">reading</span></td></tr>
      <tr><td class="left">  and one for writing, and callbacks that are invoked under certain</td><td> </td><td class="right">  and one for writing, and callbacks that are invoked under certain</td></tr>
      <tr><td class="left">  circumstances.</td><td> </td><td class="right">  circumstances.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  A bufferevent provides input and output buffers that get filled and</td><td> </td><td class="right">  A bufferevent provides input and output buffers that get filled and</td></tr>
      <tr><td class="left">  drained automatically.  The user of a bufferevent no longer deals</td><td> </td><td class="right">  drained automatically.  The user of a bufferevent no longer deals</td></tr>
      <tr><td class="left">  directly with the I/O, but instead is reading from input and writing</td><td> </td><td class="right">  directly with the I/O, but instead is reading from input and writing</td></tr>
      <tr><td class="left">  to output buffers.</td><td> </td><td class="right">  to output buffers.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Once initialized, the bufferevent structure can be used repeatedly</td><td> </td><td class="right">  Once initialized, the bufferevent structure can be used repeatedly</td></tr>
      <tr><td class="left">  with bufferevent_enable() and bufferevent_disable().</td><td> </td><td class="right">  with bufferevent_enable() and bufferevent_disable().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 212<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 213<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   and configure the bufferevent so that a BEV_EVENT_CONNECTED event will b
e</td><td> </td><td class="right">   and configure the bufferevent so that a BEV_EVENT_CONNECTED event will b
e</td></tr>
      <tr><td class="left">   yielded when it is done connecting.</td><td> </td><td class="right">   yielded when it is done connecting.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param bufev an existing bufferevent allocated with</td><td> </td><td class="right">   @param bufev an existing bufferevent allocated with</td></tr>
      <tr><td class="left">       bufferevent_socket_new().</td><td> </td><td class="right">       bufferevent_socket_new().</td></tr>
      <tr><td class="left">   @param addr the address we should connect to</td><td> </td><td class="right">   @param addr the address we should connect to</td></tr>
      <tr><td class="left">   @param socklen The length of the address</td><td> </td><td class="right">   @param socklen The length of the address</td></tr>
      <tr><td class="left">   @return 0 on success, -1 on failure.</td><td> </td><td class="right">   @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock">int bufferevent_socket_connect(struct bufferevent *<span class="delete">, const struct sockaddr 
*, int</span>);</td><td> </td><td class="rblock">int bufferevent_socket_connect(struct bufferevent *<span class="insert">bufev, const struct sock
addr *addr, int socklen</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct evdns_base;</td><td> </td><td class="right">struct evdns_base;</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Resolve the hostname 'hostname' and connect to it as with</td><td> </td><td class="right">   Resolve the hostname 'hostname' and connect to it as with</td></tr>
      <tr><td class="left">   bufferevent_socket_connect().</td><td> </td><td class="right">   bufferevent_socket_connect().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param bufev An existing bufferevent allocated with bufferevent_socket_n
ew()</td><td> </td><td class="right">   @param bufev An existing bufferevent allocated with bufferevent_socket_n
ew()</td></tr>
      <tr><td class="left">   @param evdns_base Optionally, an evdns_base to use for resolving hostnam
es</td><td> </td><td class="right">   @param evdns_base Optionally, an evdns_base to use for resolving hostnam
es</td></tr>
      <tr><td class="left">      asynchronously. May be set to NULL for a blocking resolve.</td><td> </td><td class="right">      asynchronously. May be set to NULL for a blocking resolve.</td></tr>
      <tr><td class="left">   @param family A preferred address family to resolve addresses to, or</td><td> </td><td class="right">   @param family A preferred address family to resolve addresses to, or</td></tr>
      <tr><td class="left">      AF_UNSPEC for no preference.  Only AF_INET, AF_INET6, and AF_UNSPEC a
re</td><td> </td><td class="right">      AF_UNSPEC for no preference.  Only AF_INET, AF_INET6, and AF_UNSPEC a
re</td></tr>
      <tr><td class="left">      supported.</td><td> </td><td class="right">      supported.</td></tr>
      <tr><td class="left">   @param hostname The hostname to resolve; see below for notes on recogniz
ed</td><td> </td><td class="right">   @param hostname The hostname to resolve; see below for notes on recogniz
ed</td></tr>
      <tr><td class="left">      formats</td><td> </td><td class="right">      formats</td></tr>
      <tr><td class="left">   @param port The port to connect to on the resolved address.</td><td> </td><td class="right">   @param port The port to connect to on the resolved address.</td></tr>
      <tr><td class="left">   @return 0 if successful, -1 on failure.</td><td> </td><td class="right">   @return 0 if successful, -1 on failure.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">   <span class="insert">@see bufferevent_socket_connect_hostname_hints()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int bufferevent_socket_connect_hostname(struct bufferevent *bufev,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    struct evdns_base *evdns_base, int family, const char *hostname, int po</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Resolve the hostname 'hostname' and connect to it as with</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   bufferevent_socket_connect().</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param bufev An existing bufferevent allocated with bufferevent_socket_n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ew()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param evdns_base Optionally, an evdns_base to use for resolving hostnam</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">es</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      asynchronously. May be set to NULL for a blocking resolve.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param hints_in points to an addrinfo structure that specifies criteria </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      selecting the socket address structures to be used</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param hostname The hostname to resolve; see below for notes on recogniz</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      formats</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param port The port to connect to on the resolved address.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @return 0 if successful, -1 on failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">   Recognized hostname formats are:</td><td> </td><td class="right">   Recognized hostname formats are:</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       www.example.com (hostname)</td><td> </td><td class="right">       www.example.com (hostname)</td></tr>
      <tr><td class="left">       1.2.3.4         (ipv4address)</td><td> </td><td class="right">       1.2.3.4         (ipv4address)</td></tr>
      <tr><td class="left">       ::1             (ipv6address)</td><td> </td><td class="right">       ::1             (ipv6address)</td></tr>
      <tr><td class="left">       [::1]           ([ipv6address])</td><td> </td><td class="right">       [::1]           ([ipv6address])</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Performance note: If you do not provide an evdns_base, this function</td><td> </td><td class="right">   Performance note: If you do not provide an evdns_base, this function</td></tr>
      <tr><td class="left">   may block while it waits for a DNS response.         This is probably no
t</td><td> </td><td class="right">   may block while it waits for a DNS response.         This is probably no
t</td></tr>
      <tr><td class="left">   what you want.</td><td> </td><td class="right">   what you want.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock">int <span class="delete">bufferevent_socket_connect_hostname(struct</span> bufferevent <span class="delete">*,</span></td><td> </td><td class="rblock">int <span class="insert">bufferevent_socket_connect_hostname_hints(struct</span> bufferevent <span class="insert">*bufev,</span></td></tr>
      <tr><td class="lblock">    struct evdns_base <span class="delete">*, int,</span> const char <span class="delete">*, int);</span></td><td> </td><td class="rblock">    struct evdns_base <span class="insert">*evdns_base, const struct evutil_addrinfo *hints_in,</span> </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">const char <span class="insert">*hostname, int port);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Return the error code for the last failed DNS lookup attempt made by</td><td> </td><td class="right">   Return the error code for the last failed DNS lookup attempt made by</td></tr>
      <tr><td class="left">   bufferevent_socket_connect_hostname().</td><td> </td><td class="right">   bufferevent_socket_connect_hostname().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param bev The bufferevent object.</td><td> </td><td class="right">   @param bev The bufferevent object.</td></tr>
      <tr><td class="left">   @return DNS error code.</td><td> </td><td class="right">   @return DNS error code.</td></tr>
      <tr><td class="left">   @see evutil_gai_strerror()</td><td> </td><td class="right">   @see evutil_gai_strerror()</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 889<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 910<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/** Remove 'bev' from its current rate-limit group (if any). */</td><td> </td><td class="right">/** Remove 'bev' from its current rate-limit group (if any). */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int bufferevent_remove_from_rate_limit_group(struct bufferevent *bev);</td><td> </td><td class="right">int bufferevent_remove_from_rate_limit_group(struct bufferevent *bev);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Set the size limit for single read operation.</td><td> </td><td class="right">   Set the size limit for single read operation.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Set to 0 for a reasonable default.</td><td> </td><td class="right">   Set to 0 for a reasonable default.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Return 0 on success and -1 on failure.</td><td> </td><td class="right">   Return 0 on success and -1 on failure.</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">   <span class="insert">@see evbuffer_set_max_read()</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int bufferevent_set_max_single_read(struct bufferevent *bev, size_t size);</td><td> </td><td class="right">int bufferevent_set_max_single_read(struct bufferevent *bev, size_t size);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Set the size limit for single write operation.</td><td> </td><td class="right">   Set the size limit for single write operation.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Set to 0 for a reasonable default.</td><td> </td><td class="right">   Set to 0 for a reasonable default.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Return 0 on success and -1 on failure.</td><td> </td><td class="right">   Return 0 on success and -1 on failure.</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 5 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>7 lines changed or deleted</i></th><th><i> </i></th><th><i>35 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;bufferevent_compat.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;bufferevent_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</td><td> </td><td class="right"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</td></tr>
      <tr><td class="left"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE
,</td><td> </td><td class="right"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE
,</td></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @file event2/bufferevent_compat.h</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @brief Deprecated versions of the functions in bufferevent.h: provided</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * only for backwards compatibility.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define evbuffercb bufferevent_data_cb</td><td> </td><td class="right">#define evbuffercb bufferevent_data_cb</td></tr>
      <tr><td class="left">#define everrorcb bufferevent_event_cb</td><td> </td><td class="right">#define everrorcb bufferevent_event_cb</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Create a new bufferevent for an fd.</td><td> </td><td class="right">  Create a new bufferevent for an fd.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  This function is deprecated.  Use bufferevent_socket_new and</td><td> </td><td class="right">  This function is deprecated.  Use bufferevent_socket_new and</td></tr>
      <tr><td class="left">  bufferevent_set_callbacks instead.</td><td> </td><td class="right">  bufferevent_set_callbacks instead.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 84<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 90<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">         error occurred</td><td> </td><td class="right">         error occurred</td></tr>
      <tr><td class="left">  @see bufferevent_base_set(), bufferevent_free()</td><td> </td><td class="right">  @see bufferevent_base_set(), bufferevent_free()</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct bufferevent *bufferevent_new(evutil_socket_t fd,</td><td> </td><td class="right">struct bufferevent *bufferevent_new(evutil_socket_t fd,</td></tr>
      <tr><td class="left">    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);</td><td> </td><td class="right">    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Set the read and write timeout for a buffered event.</td><td> </td><td class="right">  Set the read and write timeout for a buffered event.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">@deprecated Use bufferevent_set_timeouts instead.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">  @param bufev the bufferevent to be modified</td><td> </td><td class="right">  @param bufev the bufferevent to be modified</td></tr>
      <tr><td class="left">  @param timeout_read the read timeout</td><td> </td><td class="right">  @param timeout_read the read timeout</td></tr>
      <tr><td class="left">  @param timeout_write the write timeout</td><td> </td><td class="right">  @param timeout_write the write timeout</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void bufferevent_settimeout(struct bufferevent *bufev,</td><td> </td><td class="right">void bufferevent_settimeout(struct bufferevent *bufev,</td></tr>
      <tr><td class="left">    int timeout_read, int timeout_write);</td><td> </td><td class="right">    int timeout_read, int timeout_write);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define EVBUFFER_READ          BEV_EVENT_READING</td><td> </td><td class="right">#define EVBUFFER_READ          BEV_EVENT_READING</td></tr>
      <tr><td class="left">#define EVBUFFER_WRITE         BEV_EVENT_WRITING</td><td> </td><td class="right">#define EVBUFFER_WRITE         BEV_EVENT_WRITING</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 2 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>8 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;bufferevent_ssl.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;bufferevent_ssl.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFEREVENT_SSL_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFEREVENT_SSL_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFEREVENT_SSL_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFEREVENT_SSL_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/bufferevent_ssl.h</td><td> </td><td class="right">/** @file event2/bufferevent_ssl.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">    OpenSSL support for bufferevents.</td><td> </td><td class="rblock">    <span class="insert">@brief </span>OpenSSL support for bufferevents.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left">#include &lt;event2/bufferevent.h&gt;</td><td> </td><td class="right">#include &lt;event2/bufferevent.h&gt;</td></tr>
      <tr><td class="left">#include &lt;event2/util.h&gt;</td><td> </td><td class="right">#include &lt;event2/util.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;dns.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;dns.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 52<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 52<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * You may wish to replace the word "Parts" with something else depending o
n</td><td> </td><td class="right"> * You may wish to replace the word "Parts" with something else depending o
n</td></tr>
      <tr><td class="left"> * the amount of original code.</td><td> </td><td class="right"> * the amount of original code.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * (Derivative works does not include programs which link against, run or i
nclude</td><td> </td><td class="right"> * (Derivative works does not include programs which link against, run or i
nclude</td></tr>
      <tr><td class="left"> * the source verbatim in their source distributions)</td><td> </td><td class="right"> * the source verbatim in their source distributions)</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/dns.h</td><td> </td><td class="right">/** @file event2/dns.h</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* @brief Provides a few APIs to use for resolving DNS names, and a facilit</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * for implementing simple DNS servers.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="left"> * Welcome, gentle reader</td><td> </td><td class="right"> * Welcome, gentle reader</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Async DNS lookups are really a whole lot harder than they should be,</td><td> </td><td class="right"> * Async DNS lookups are really a whole lot harder than they should be,</td></tr>
      <tr><td class="left"> * mostly stemming from the fact that the libc resolver has never been</td><td> </td><td class="right"> * mostly stemming from the fact that the libc resolver has never been</td></tr>
      <tr><td class="left"> * very good at them. Before you use this library you should see if libc</td><td> </td><td class="right"> * very good at them. Before you use this library you should see if libc</td></tr>
      <tr><td class="left"> * can do the job for you with the modern async call getaddrinfo_a</td><td> </td><td class="right"> * can do the job for you with the modern async call getaddrinfo_a</td></tr>
      <tr><td class="left"> * (see http://www.imperialviolet.org/page25.html#e498). Otherwise,</td><td> </td><td class="right"> * (see http://www.imperialviolet.org/page25.html#e498). Otherwise,</td></tr>
      <tr><td class="left"> * please continue.</td><td> </td><td class="right"> * please continue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The library keeps track of the state of nameservers and will avoid</td><td> </td><td class="right"> * The library keeps track of the state of nameservers and will avoid</td></tr>
      <tr><td class="left"> * them when they go down. Otherwise it will round robin between them.</td><td> </td><td class="right"> * them when they go down. Otherwise it will round robin between them.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Quick start guide:</td><td> </td><td class="right"> * Quick start guide:</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @code</span></td></tr>
      <tr><td class="left"> *   #include "evdns.h"</td><td> </td><td class="right"> *   #include "evdns.h"</td></tr>
      <tr><td class="left"> *   void callback(int result, char type, int count, int ttl,</td><td> </td><td class="right"> *   void callback(int result, char type, int count, int ttl,</td></tr>
      <tr><td class="left"> *              void *addresses, void *arg);</td><td> </td><td class="right"> *              void *addresses, void *arg);</td></tr>
      <tr><td class="left"> *   evdns_resolv_conf_parse(DNS_OPTIONS_ALL, "/etc/resolv.conf");</td><td> </td><td class="right"> *   evdns_resolv_conf_parse(DNS_OPTIONS_ALL, "/etc/resolv.conf");</td></tr>
      <tr><td class="left"> *   evdns_resolve("www.hostname.com", 0, callback, NULL);</td><td> </td><td class="right"> *   evdns_resolve("www.hostname.com", 0, callback, NULL);</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"> *</td><td> </td><td class="rblock"> *<span class="insert">@endcode</span></td></tr>
      <tr><td class="left"> * When the lookup is complete the callback function is called. The</td><td> </td><td class="right"> * When the lookup is complete the callback function is called. The</td></tr>
      <tr><td class="left"> * first argument will be one of the DNS_ERR_* defines in evdns.h.</td><td> </td><td class="right"> * first argument will be one of the DNS_ERR_* defines in evdns.h.</td></tr>
      <tr><td class="left"> * Hopefully it will be DNS_ERR_NONE, in which case type will be</td><td> </td><td class="right"> * Hopefully it will be DNS_ERR_NONE, in which case type will be</td></tr>
      <tr><td class="left"> * DNS_IPv4_A, count will be the number of IP addresses, ttl is the time</td><td> </td><td class="right"> * DNS_IPv4_A, count will be the number of IP addresses, ttl is the time</td></tr>
      <tr><td class="left"> * which the data can be cached for (in seconds), addresses will point</td><td> </td><td class="right"> * which the data can be cached for (in seconds), addresses will point</td></tr>
      <tr><td class="left"> * to an array of uint32_t's and arg will be whatever you passed to</td><td> </td><td class="right"> * to an array of uint32_t's and arg will be whatever you passed to</td></tr>
      <tr><td class="left"> * evdns_resolve.</td><td> </td><td class="right"> * evdns_resolve.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Searching:</td><td> </td><td class="right"> * Searching:</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 109<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 113<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The order of searches depends on the number of dots in the name. If the</td><td> </td><td class="right"> * The order of searches depends on the number of dots in the name. If the</td></tr>
      <tr><td class="left"> * number is greater than the ndots setting then the names is first tried</td><td> </td><td class="right"> * number is greater than the ndots setting then the names is first tried</td></tr>
      <tr><td class="left"> * globally. Otherwise each search domain is appended in turn.</td><td> </td><td class="right"> * globally. Otherwise each search domain is appended in turn.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The ndots setting can either be set from a resolv.conf, or by calling</td><td> </td><td class="right"> * The ndots setting can either be set from a resolv.conf, or by calling</td></tr>
      <tr><td class="left"> * evdns_search_ndots_set.</td><td> </td><td class="right"> * evdns_search_ndots_set.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * For example, with ndots set to 1 (the default) and a search domain list 
of</td><td> </td><td class="right"> * For example, with ndots set to 1 (the default) and a search domain list 
of</td></tr>
      <tr><td class="left"> * ["myhome.net"]:</td><td> </td><td class="right"> * ["myhome.net"]:</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * &lt;pre&gt;</span></td></tr>
      <tr><td class="left"> *  Query: www</td><td> </td><td class="right"> *  Query: www</td></tr>
      <tr><td class="left"> *  Order: www.myhome.net, www.</td><td> </td><td class="right"> *  Order: www.myhome.net, www.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> *  Query: www.abc</td><td> </td><td class="right"> *  Query: www.abc</td></tr>
      <tr><td class="left"> *  Order: www.abc., www.abc.myhome.net</td><td> </td><td class="right"> *  Order: www.abc., www.abc.myhome.net</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"> *</td><td> </td><td class="rblock"> *<span class="insert"> &lt;/pre&gt;</span></td></tr>
      <tr><td class="left"> * Internals:</td><td> </td><td class="right"> * Internals:</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Requests are kept in two queues. The first is the inflight queue. In</td><td> </td><td class="right"> * Requests are kept in two queues. The first is the inflight queue. In</td></tr>
      <tr><td class="left"> * this queue requests have an allocated transaction id and nameserver.</td><td> </td><td class="right"> * this queue requests have an allocated transaction id and nameserver.</td></tr>
      <tr><td class="left"> * They will soon be transmitted if they haven't already been.</td><td> </td><td class="right"> * They will soon be transmitted if they haven't already been.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The second is the waiting queue. The size of the inflight ring is</td><td> </td><td class="right"> * The second is the waiting queue. The size of the inflight ring is</td></tr>
      <tr><td class="left"> * limited and all other requests wait in waiting queue for space. This</td><td> </td><td class="right"> * limited and all other requests wait in waiting queue for space. This</td></tr>
      <tr><td class="left"> * bounds the number of concurrent requests so that we don't flood the</td><td> </td><td class="right"> * bounds the number of concurrent requests so that we don't flood the</td></tr>
      <tr><td class="left"> * nameserver. Several algorithms require a full walk of the inflight</td><td> </td><td class="right"> * nameserver. Several algorithms require a full walk of the inflight</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 252<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 258<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define EVDNS_BASE_NAMESERVERS_NO_DEFAULT 0x10000</td><td> </td><td class="right">#define EVDNS_BASE_NAMESERVERS_NO_DEFAULT 0x10000</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Initialize the asynchronous DNS library.</td><td> </td><td class="right">  Initialize the asynchronous DNS library.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  This function initializes support for non-blocking name resolution by</td><td> </td><td class="right">  This function initializes support for non-blocking name resolution by</td></tr>
      <tr><td class="left">  calling evdns_resolv_conf_parse() on UNIX and</td><td> </td><td class="right">  calling evdns_resolv_conf_parse() on UNIX and</td></tr>
      <tr><td class="left">  evdns_config_windows_nameservers() on Windows.</td><td> </td><td class="right">  evdns_config_windows_nameservers() on Windows.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param event_base the event base to associate the dns client with</td><td> </td><td class="right">  @param event_base the event base to associate the dns client with</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock">  @param <span class="delete">flag</span>s any of EVDNS_BASE_INITIALIZE_NAMESERVERS|</td><td> </td><td class="rblock">  @param <span class="insert">initialize_nameserver</span>s any of EVDNS_BASE_INITIALIZE_NAMESERVERS|</td></tr>
      <tr><td class="left">    EVDNS_BASE_DISABLE_WHEN_INACTIVE|EVDNS_BASE_NAMESERVERS_NO_DEFAULT</td><td> </td><td class="right">    EVDNS_BASE_DISABLE_WHEN_INACTIVE|EVDNS_BASE_NAMESERVERS_NO_DEFAULT</td></tr>
      <tr><td class="left">  @return evdns_base object if successful, or NULL if an error occurred.</td><td> </td><td class="right">  @return evdns_base object if successful, or NULL if an error occurred.</td></tr>
      <tr><td class="left">  @see evdns_base_free()</td><td> </td><td class="right">  @see evdns_base_free()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evdns_base * evdns_base_new(struct event_base *event_base, int initi
alize_nameservers);</td><td> </td><td class="right">struct evdns_base * evdns_base_new(struct event_base *event_base, int initi
alize_nameservers);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Shut down the asynchronous DNS resolver and terminate all active requests
.</td><td> </td><td class="right">  Shut down the asynchronous DNS resolver and terminate all active requests
.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  If the 'fail_requests' option is enabled, all active requests will return</td><td> </td><td class="right">  If the 'fail_requests' option is enabled, all active requests will return</td></tr>
      <tr><td class="left">  an empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise,</td><td> </td><td class="right">  an empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise,</td></tr>
      <tr><td class="left">  the requests will be silently discarded.</td><td> </td><td class="right">  the requests will be silently discarded.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock">  @param <span class="delete">evdns_</span>base the evdns base to free</td><td> </td><td class="rblock">  @param base the evdns base to free</td></tr>
      <tr><td class="left">  @param fail_requests if zero, active requests will be aborted; if non-zer
o,</td><td> </td><td class="right">  @param fail_requests if zero, active requests will be aborted; if non-zer
o,</td></tr>
      <tr><td class="left">               active requests will return DNS_ERR_SHUTDOWN.</td><td> </td><td class="right">               active requests will return DNS_ERR_SHUTDOWN.</td></tr>
      <tr><td class="left">  @see evdns_base_new()</td><td> </td><td class="right">  @see evdns_base_new()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evdns_base_free(struct evdns_base *base, int fail_requests);</td><td> </td><td class="right">void evdns_base_free(struct evdns_base *base, int fail_requests);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Remove all hosts entries that have been loaded into the event_base via</td><td> </td><td class="right">   Remove all hosts entries that have been loaded into the event_base via</td></tr>
      <tr><td class="left">   evdns_base_load_hosts or via event_base_resolv_conf_parse.</td><td> </td><td class="right">   evdns_base_load_hosts or via event_base_resolv_conf_parse.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock">   @param <span class="delete">evdns_</span>base the evdns base to remove outdated host addresses from</td><td> </td><td class="rblock">   @param base the evdns base to remove outdated host addresses from</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evdns_base_clear_host_addresses(struct evdns_base *base);</td><td> </td><td class="right">void evdns_base_clear_host_addresses(struct evdns_base *base);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Convert a DNS error code to a string.</td><td> </td><td class="right">  Convert a DNS error code to a string.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param err the DNS error code</td><td> </td><td class="right">  @param err the DNS error code</td></tr>
      <tr><td class="left">  @return a string containing an explanation of the error code</td><td> </td><td class="right">  @return a string containing an explanation of the error code</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 8 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>5 lines changed or deleted</i></th><th><i> </i></th><th><i>12 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;dns_compat.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;dns_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_DNS_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_DNS_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_DNS_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_DNS_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/dns_compat.h</td><td> </td><td class="right">/** @file event2/dns_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  <span class="delete">Potentially non-threadsafe versions of the functions in dns.h: pro</span>vided</td><td> </td><td class="rblock">  <span class="insert">@brief Potentially non-threadsafe versions of the functions in dns.h: pro
</span>vided</td></tr>
      <tr><td class="left">  only for backwards compatibility.</td><td> </td><td class="right">  only for backwards compatibility.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left">#ifdef EVENT__HAVE_SYS_TYPES_H</td><td> </td><td class="right">#ifdef EVENT__HAVE_SYS_TYPES_H</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;event-config.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;event-config.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 52<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 52<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define EVENT__HAVE_CLOCK_GETTIME 1</td><td> </td><td class="right">#define EVENT__HAVE_CLOCK_GETTIME 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the declaration of `CTL_KERN', and to 0 if you</td><td> </td><td class="right">/* Define to 1 if you have the declaration of `CTL_KERN', and to 0 if you</td></tr>
      <tr><td class="left">   don't. */</td><td> </td><td class="right">   don't. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_DECL_CTL_KERN 1</td><td> </td><td class="right">#define EVENT__HAVE_DECL_CTL_KERN 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the declaration of `KERN_ARND', and to 0 if you</td><td> </td><td class="right">/* Define to 1 if you have the declaration of `KERN_ARND', and to 0 if you</td></tr>
      <tr><td class="left">   don't. */</td><td> </td><td class="right">   don't. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_DECL_KERN_ARND 0</td><td> </td><td class="right">#define EVENT__HAVE_DECL_KERN_ARND 0</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"><span class="delete">/* Define to 1 if you have the declaration of `KERN_RANDOM', and to 0 if yo</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">u</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   don't. */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">#define EVENT__HAVE_DECL_KERN_RANDOM 1</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/* Define to 1 if you have the declaration of `RANDOM_UUID', and to 0 if yo</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">u</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   don't. */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">#define EVENT__HAVE_DECL_RANDOM_UUID 1</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/* Define if /dev/poll is available */</td><td> </td><td class="right">/* Define if /dev/poll is available */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_DEVPOLL */</td><td> </td><td class="right">/* #undef EVENT__HAVE_DEVPOLL */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;dlfcn.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;dlfcn.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_DLFCN_H 1</td><td> </td><td class="right">#define EVENT__HAVE_DLFCN_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define if your system supports the epoll system calls */</td><td> </td><td class="right">/* Define if your system supports the epoll system calls */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_EPOLL 1</td><td> </td><td class="right">#define EVENT__HAVE_EPOLL 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `epoll_create1' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `epoll_create1' function. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 123<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 115<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `getifaddrs' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `getifaddrs' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_GETIFADDRS 1</td><td> </td><td class="right">#define EVENT__HAVE_GETIFADDRS 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `getnameinfo' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `getnameinfo' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_GETNAMEINFO 1</td><td> </td><td class="right">#define EVENT__HAVE_GETNAMEINFO 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `getprotobynumber' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `getprotobynumber' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_GETPROTOBYNUMBER 1</td><td> </td><td class="right">#define EVENT__HAVE_GETPROTOBYNUMBER 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define to 1 if you have the `getrandom' function. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVENT__HAVE_GETRANDOM 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define to 1 if you have the `getservbyname' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `getservbyname' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_GETSERVBYNAME 1</td><td> </td><td class="right">#define EVENT__HAVE_GETSERVBYNAME 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `gettimeofday' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `gettimeofday' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_GETTIMEOFDAY 1</td><td> </td><td class="right">#define EVENT__HAVE_GETTIMEOFDAY 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;ifaddrs.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;ifaddrs.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_IFADDRS_H 1</td><td> </td><td class="right">#define EVENT__HAVE_IFADDRS_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `inet_ntop' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `inet_ntop' function. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 261<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 256<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;string.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;string.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRING_H 1</td><td> </td><td class="right">#define EVENT__HAVE_STRING_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `strlcpy' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `strlcpy' function. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_STRLCPY */</td><td> </td><td class="right">/* #undef EVENT__HAVE_STRLCPY */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `strsep' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `strsep' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRSEP 1</td><td> </td><td class="right">#define EVENT__HAVE_STRSEP 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define to 1 if you have the `strsignal' function. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVENT__HAVE_STRSIGNAL 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define to 1 if you have the `strtok_r' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `strtok_r' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRTOK_R 1</td><td> </td><td class="right">#define EVENT__HAVE_STRTOK_R 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `strtoll' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `strtoll' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRTOLL 1</td><td> </td><td class="right">#define EVENT__HAVE_STRTOLL 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if the system has the type `struct addrinfo'. */</td><td> </td><td class="right">/* Define to 1 if the system has the type `struct addrinfo'. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRUCT_ADDRINFO 1</td><td> </td><td class="right">#define EVENT__HAVE_STRUCT_ADDRINFO 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if the system has the type `struct in6_addr'. */</td><td> </td><td class="right">/* Define to 1 if the system has the type `struct in6_addr'. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 330<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 328<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/mman.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/mman.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_MMAN_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_MMAN_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/param.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/param.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_PARAM_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_PARAM_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/queue.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/queue.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_QUEUE_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_QUEUE_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define to 1 if you have the &lt;sys/random.h&gt; header file. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVENT__HAVE_SYS_RANDOM_H 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/resource.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/resource.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_RESOURCE_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_RESOURCE_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/select.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/select.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_SELECT_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_SELECT_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/sendfile.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/sendfile.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_SENDFILE_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_SENDFILE_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/socket.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/socket.h&gt; header file. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 430<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 431<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/* Define to 1 if compiler have __FUNCTION__ */</td><td> </td><td class="right">/* Define to 1 if compiler have __FUNCTION__ */</td></tr>
      <tr><td class="left">#define EVENT__HAVE___FUNCTION__ 1</td><td> </td><td class="right">#define EVENT__HAVE___FUNCTION__ 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if compiler have __func__ */</td><td> </td><td class="right">/* Define to 1 if compiler have __func__ */</td></tr>
      <tr><td class="left">#define EVENT__HAVE___func__ 1</td><td> </td><td class="right">#define EVENT__HAVE___func__ 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the sub-directory where libtool stores uninstalled libraries. 
*/</td><td> </td><td class="right">/* Define to the sub-directory where libtool stores uninstalled libraries. 
*/</td></tr>
      <tr><td class="left">#define EVENT__LT_OBJDIR ".libs/"</td><td> </td><td class="right">#define EVENT__LT_OBJDIR ".libs/"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Numeric representation of the version */</td><td> </td><td class="right">/* Numeric representation of the version */</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock">#define EVENT__NUMERIC_VERSION 0x020<span class="delete">10b00</span></td><td> </td><td class="rblock">#define EVENT__NUMERIC_VERSION 0x020<span class="insert">20001</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Name of package */</td><td> </td><td class="right">/* Name of package */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE "libevent"</td><td> </td><td class="right">#define EVENT__PACKAGE "libevent"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the address where bug reports for this package should be sent.
 */</td><td> </td><td class="right">/* Define to the address where bug reports for this package should be sent.
 */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE_BUGREPORT ""</td><td> </td><td class="right">#define EVENT__PACKAGE_BUGREPORT ""</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the full name of this package. */</td><td> </td><td class="right">/* Define to the full name of this package. */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE_NAME "libevent"</td><td> </td><td class="right">#define EVENT__PACKAGE_NAME "libevent"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the full name and version of this package. */</td><td> </td><td class="right">/* Define to the full name and version of this package. */</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock">#define EVENT__PACKAGE_STRING "libevent 2.<span class="delete">1.11-stable</span>"</td><td> </td><td class="rblock">#define EVENT__PACKAGE_STRING "libevent 2.<span class="insert">2.0-alpha-dev</span>"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the one symbol short name of this package. */</td><td> </td><td class="right">/* Define to the one symbol short name of this package. */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE_TARNAME "libevent"</td><td> </td><td class="right">#define EVENT__PACKAGE_TARNAME "libevent"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the home page for this package. */</td><td> </td><td class="right">/* Define to the home page for this package. */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE_URL ""</td><td> </td><td class="right">#define EVENT__PACKAGE_URL ""</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the version of this package. */</td><td> </td><td class="right">/* Define to the version of this package. */</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock">#define EVENT__PACKAGE_VERSION "2.<span class="delete">1.11-stable</span>"</td><td> </td><td class="rblock">#define EVENT__PACKAGE_VERSION "2.<span class="insert">2.0-alpha-dev</span>"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to necessary symbol if this constant uses a non-standard name on</td><td> </td><td class="right">/* Define to necessary symbol if this constant uses a non-standard name on</td></tr>
      <tr><td class="left">   your system. */</td><td> </td><td class="right">   your system. */</td></tr>
      <tr><td class="left">/* #undef EVENT__PTHREAD_CREATE_JOINABLE */</td><td> </td><td class="right">/* #undef EVENT__PTHREAD_CREATE_JOINABLE */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* The size of `int', as computed by sizeof. */</td><td> </td><td class="right">/* The size of `int', as computed by sizeof. */</td></tr>
      <tr><td class="left">#define EVENT__SIZEOF_INT 4</td><td> </td><td class="right">#define EVENT__SIZEOF_INT 4</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* The size of `long', as computed by sizeof. */</td><td> </td><td class="right">/* The size of `long', as computed by sizeof. */</td></tr>
      <tr><td class="left">#define EVENT__SIZEOF_LONG 8</td><td> </td><td class="right">#define EVENT__SIZEOF_LONG 8</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 512<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 513<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/* Enable extensions on HP NonStop.  */</td><td> </td><td class="right">/* Enable extensions on HP NonStop.  */</td></tr>
      <tr><td class="left">#ifndef _TANDEM_SOURCE</td><td> </td><td class="right">#ifndef _TANDEM_SOURCE</td></tr>
      <tr><td class="left"># define _TANDEM_SOURCE 1</td><td> </td><td class="right"># define _TANDEM_SOURCE 1</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">/* Enable general extensions on Solaris.  */</td><td> </td><td class="right">/* Enable general extensions on Solaris.  */</td></tr>
      <tr><td class="left">#ifndef __EXTENSIONS__</td><td> </td><td class="right">#ifndef __EXTENSIONS__</td></tr>
      <tr><td class="left"># define __EXTENSIONS__ 1</td><td> </td><td class="right"># define __EXTENSIONS__ 1</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Version number of package */</td><td> </td><td class="right">/* Version number of package */</td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock">#define EVENT__VERSION "2.<span class="delete">1.11-stable</span>"</td><td> </td><td class="rblock">#define EVENT__VERSION "2.<span class="insert">2.0-alpha-dev</span>"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Enable large inode numbers on Mac OS X 10.5.  */</td><td> </td><td class="right">/* Enable large inode numbers on Mac OS X 10.5.  */</td></tr>
      <tr><td class="left">#ifndef _DARWIN_USE_64_BIT_INODE</td><td> </td><td class="right">#ifndef _DARWIN_USE_64_BIT_INODE</td></tr>
      <tr><td class="left"># define _DARWIN_USE_64_BIT_INODE 1</td><td> </td><td class="right"># define _DARWIN_USE_64_BIT_INODE 1</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Number of bits in a file offset, on hosts where this is settable. */</td><td> </td><td class="right">/* Number of bits in a file offset, on hosts where this is settable. */</td></tr>
      <tr><td class="left">/* #undef _FILE_OFFSET_BITS */</td><td> </td><td class="right">/* #undef _FILE_OFFSET_BITS */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define for large files, on AIX-style hosts. */</td><td> </td><td class="right">/* Define for large files, on AIX-style hosts. */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 8 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>14 lines changed or deleted</i></th><th><i> </i></th><th><i>13 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;event.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;event.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 177<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 177<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event2/dns.h</td><td> </td><td class="right">  event2/dns.h</td></tr>
      <tr><td class="left">  Asynchronous DNS resolution</td><td> </td><td class="right">  Asynchronous DNS resolution</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event2/http.h</td><td> </td><td class="right">  event2/http.h</td></tr>
      <tr><td class="left">  An embedded libevent-based HTTP server</td><td> </td><td class="right">  An embedded libevent-based HTTP server</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event2/rpc.h</td><td> </td><td class="right">  event2/rpc.h</td></tr>
      <tr><td class="left">  A framework for creating RPC servers and clients</td><td> </td><td class="right">  A framework for creating RPC servers and clients</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">event2/watch.h</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  "Prepare" and "check" watchers.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/event.h</td><td> </td><td class="right">/** @file event2/event.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock">  <span class="delete">Core functions for waiting for and receiving events, and using event base
</span>s.</td><td> </td><td class="rblock">  <span class="insert">@brief Core functions for waiting for and receiving events, and using eve
nt base</span>s.</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left">#ifdef EVENT__HAVE_SYS_TYPES_H</td><td> </td><td class="right">#ifdef EVENT__HAVE_SYS_TYPES_H</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 223<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 225<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * @see event_base_new(), event_base_free(), event_base_loop(),</td><td> </td><td class="right"> * @see event_base_new(), event_base_free(), event_base_loop(),</td></tr>
      <tr><td class="left"> *    event_base_new_with_config()</td><td> </td><td class="right"> *    event_base_new_with_config()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">struct event_base</td><td> </td><td class="right">struct event_base</td></tr>
      <tr><td class="left">#ifdef EVENT_IN_DOXYGEN_</td><td> </td><td class="right">#ifdef EVENT_IN_DOXYGEN_</td></tr>
      <tr><td class="left">{/*Empty body so that doxygen will generate documentation here.*/}</td><td> </td><td class="right">{/*Empty body so that doxygen will generate documentation here.*/}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">;</td><td> </td><td class="right">;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"> <span class="delete">* @struct event</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> * Structure to represent a single event.</td><td> </td><td class="right"> * Structure to represent a single event.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * An event can have some underlying condition it represents: a socket</td><td> </td><td class="right"> * An event can have some underlying condition it represents: a socket</td></tr>
      <tr><td class="left"> * becoming readable or writeable (or both), or a signal becoming raised.</td><td> </td><td class="right"> * becoming readable or writeable (or both), or a signal becoming raised.</td></tr>
      <tr><td class="left"> * (An event that represents no underlying condition is still useful: you</td><td> </td><td class="right"> * (An event that represents no underlying condition is still useful: you</td></tr>
      <tr><td class="left"> * can use one to implement a timer, or to communicate between threads.)</td><td> </td><td class="right"> * can use one to implement a timer, or to communicate between threads.)</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Generally, you can create events with event_new(), then make them</td><td> </td><td class="right"> * Generally, you can create events with event_new(), then make them</td></tr>
      <tr><td class="left"> * pending with event_add().  As your event_base runs, it will run the</td><td> </td><td class="right"> * pending with event_add().  As your event_base runs, it will run the</td></tr>
      <tr><td class="left"> * callbacks of an events whose conditions are triggered.  When you no</td><td> </td><td class="right"> * callbacks of an events whose conditions are triggered.  When you no</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 372<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 372<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  active, or until something calls event_base_loopbreak() or</td><td> </td><td class="right">  active, or until something calls event_base_loopbreak() or</td></tr>
      <tr><td class="left">  event_base_loopexit().</td><td> </td><td class="right">  event_base_loopexit().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param base the event_base structure returned by event_base_new() or</td><td> </td><td class="right">  @param base the event_base structure returned by event_base_new() or</td></tr>
      <tr><td class="left">     event_base_new_with_config()</td><td> </td><td class="right">     event_base_new_with_config()</td></tr>
      <tr><td class="left">  @return 0 if successful, -1 if an error occurred, or 1 if we exited becau
se</td><td> </td><td class="right">  @return 0 if successful, -1 if an error occurred, or 1 if we exited becau
se</td></tr>
      <tr><td class="left">     no events were pending or active.</td><td> </td><td class="right">     no events were pending or active.</td></tr>
      <tr><td class="left">  @see event_base_loop()</td><td> </td><td class="right">  @see event_base_loop()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock">int event_base_dispatch(struct event_base *);</td><td> </td><td class="rblock">int event_base_dispatch(struct event_base *<span class="insert">base</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> Get the kernel event notification mechanism used by Libevent.</td><td> </td><td class="right"> Get the kernel event notification mechanism used by Libevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right"> @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left"> @return a string identifying the kernel event mechanism (kqueue, epoll, et
c.)</td><td> </td><td class="right"> @return a string identifying the kernel event mechanism (kqueue, epoll, et
c.)</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock">const char *event_base_get_method(const struct event_base *);</td><td> </td><td class="rblock">const char *event_base_get_method(const struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Gets all event notification mechanisms supported by Libevent.</td><td> </td><td class="right">   Gets all event notification mechanisms supported by Libevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   This functions returns the event mechanism in order preferred by</td><td> </td><td class="right">   This functions returns the event mechanism in order preferred by</td></tr>
      <tr><td class="left">   Libevent.  Note that this list will include all backends that</td><td> </td><td class="right">   Libevent.  Note that this list will include all backends that</td></tr>
      <tr><td class="left">   Libevent has compiled-in support for, and will not necessarily check</td><td> </td><td class="right">   Libevent has compiled-in support for, and will not necessarily check</td></tr>
      <tr><td class="left">   your OS to see whether it has the required resources.</td><td> </td><td class="right">   your OS to see whether it has the required resources.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @return an array with pointers to the names of support methods.</td><td> </td><td class="right">   @return an array with pointers to the names of support methods.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 440<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 440<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   future libevent versions.  The return value is an indication of the work</td><td> </td><td class="right">   future libevent versions.  The return value is an indication of the work</td></tr>
      <tr><td class="left">   load, but the user shouldn't rely on the exact value as this may change 
in</td><td> </td><td class="right">   load, but the user shouldn't rely on the exact value as this may change 
in</td></tr>
      <tr><td class="left">   the future.</td><td> </td><td class="right">   the future.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right">   @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left">   @param flags a bitwise combination of the kinds of events to aggregate</td><td> </td><td class="right">   @param flags a bitwise combination of the kinds of events to aggregate</td></tr>
      <tr><td class="left">       counts for</td><td> </td><td class="right">       counts for</td></tr>
      <tr><td class="left">   @return the number of events specified in the flags</td><td> </td><td class="right">   @return the number of events specified in the flags</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock">int event_base_get_num_events(struct event_base *<span class="delete">, unsigned int</span>);</td><td> </td><td class="rblock">int event_base_get_num_events(struct event_base *<span class="insert">eb, unsigned int flags</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Get the maximum number of events in a given event_base as specified in th
e</td><td> </td><td class="right">  Get the maximum number of events in a given event_base as specified in th
e</td></tr>
      <tr><td class="left">  flags.</td><td> </td><td class="right">  flags.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left">  @param flags a bitwise combination of the kinds of events to aggregate</td><td> </td><td class="right">  @param flags a bitwise combination of the kinds of events to aggregate</td></tr>
      <tr><td class="left">         counts for</td><td> </td><td class="right">         counts for</td></tr>
      <tr><td class="left">  @param clear option used to reset the maximum count.</td><td> </td><td class="right">  @param clear option used to reset the maximum count.</td></tr>
      <tr><td class="left">  @return the number of events specified in the flags</td><td> </td><td class="right">  @return the number of events specified in the flags</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock">int event_base_get_max_events(struct event_base *<span class="delete">, unsigned int, int</span>);</td><td> </td><td class="rblock">int event_base_get_max_events(struct event_base *<span class="insert">eb, unsigned int flags, in
t clear</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Allocates a new event configuration object.</td><td> </td><td class="right">   Allocates a new event configuration object.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   The event configuration object can be used to change the behavior of</td><td> </td><td class="right">   The event configuration object can be used to change the behavior of</td></tr>
      <tr><td class="left">   an event base.</td><td> </td><td class="right">   an event base.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @return an event_config object that can be used to store configuration, 
or</td><td> </td><td class="right">   @return an event_config object that can be used to store configuration, 
or</td></tr>
      <tr><td class="left">     NULL if an error is encountered.</td><td> </td><td class="right">     NULL if an error is encountered.</td></tr>
      <tr><td class="left">   @see event_base_new_with_config(), event_config_free(), event_config</td><td> </td><td class="right">   @see event_base_new_with_config(), event_config_free(), event_config</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 677<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 677<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  Use event_base_new_with_config() to initialize a new event base, taking</td><td> </td><td class="right">  Use event_base_new_with_config() to initialize a new event base, taking</td></tr>
      <tr><td class="left">  the specified configuration under consideration.  The configuration objec
t</td><td> </td><td class="right">  the specified configuration under consideration.  The configuration objec
t</td></tr>
      <tr><td class="left">  can currently be used to avoid certain event notification mechanisms.</td><td> </td><td class="right">  can currently be used to avoid certain event notification mechanisms.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param cfg the event configuration object</td><td> </td><td class="right">  @param cfg the event configuration object</td></tr>
      <tr><td class="left">  @return an initialized event_base that can be used to registering events,</td><td> </td><td class="right">  @return an initialized event_base that can be used to registering events,</td></tr>
      <tr><td class="left">     or NULL if no event base can be created with the requested event_confi
g.</td><td> </td><td class="right">     or NULL if no event base can be created with the requested event_confi
g.</td></tr>
      <tr><td class="left">  @see event_base_new(), event_base_free(), event_init(), event_assign()</td><td> </td><td class="right">  @see event_base_new(), event_base_free(), event_init(), event_assign()</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock">struct event_base *event_base_new_with_config(const struct event_config *);</td><td> </td><td class="rblock">struct event_base *event_base_new_with_config(const struct event_config *<span class="insert">cf
g</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Deallocate all memory associated with an event_base, and free the base.</td><td> </td><td class="right">  Deallocate all memory associated with an event_base, and free the base.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Note that this function will not close any fds or free any memory passed</td><td> </td><td class="right">  Note that this function will not close any fds or free any memory passed</td></tr>
      <tr><td class="left">  to event_new as the argument to callback.</td><td> </td><td class="right">  to event_new as the argument to callback.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  If there are any pending finalizer callbacks, this function will invoke</td><td> </td><td class="right">  If there are any pending finalizer callbacks, this function will invoke</td></tr>
      <tr><td class="left">  them.</td><td> </td><td class="right">  them.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb an event_base to be freed</td><td> </td><td class="right">  @param eb an event_base to be freed</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock">void event_base_free(struct event_base *);</td><td> </td><td class="rblock">void event_base_free(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   As event_base_free, but do not run finalizers.</td><td> </td><td class="right">   As event_base_free, but do not run finalizers.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void event_base_free_nofinalize(struct event_base *);</td><td> </td><td class="right">void event_base_free_nofinalize(struct event_base *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @name Log severities</td><td> </td><td class="right">/** @name Log severities</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">/**@{*/</td><td> </td><td class="right">/**@{*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 786<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 786<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Associate a different event base with an event.</td><td> </td><td class="right">  Associate a different event base with an event.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The event to be associated must not be currently active or pending.</td><td> </td><td class="right">  The event to be associated must not be currently active or pending.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event base</td><td> </td><td class="right">  @param eb the event base</td></tr>
      <tr><td class="left">  @param ev the event</td><td> </td><td class="right">  @param ev the event</td></tr>
      <tr><td class="left">  @return 0 on success, -1 on failure.</td><td> </td><td class="right">  @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock">int event_base_set(struct event_base *<span class="delete">, struct event *</span>);</td><td> </td><td class="rblock">int event_base_set(struct event_base *<span class="insert">eb, struct event *ev</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @name Loop flags</td><td> </td><td class="right">/** @name Loop flags</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    These flags control the behavior of event_base_loop().</td><td> </td><td class="right">    These flags control the behavior of event_base_loop().</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">/**@{*/</td><td> </td><td class="right">/**@{*/</td></tr>
      <tr><td class="left">/** Block until we have an active event, then exit once all active events</td><td> </td><td class="right">/** Block until we have an active event, then exit once all active events</td></tr>
      <tr><td class="left"> * have had their callbacks run. */</td><td> </td><td class="right"> * have had their callbacks run. */</td></tr>
      <tr><td class="left">#define EVLOOP_ONCE    0x01</td><td> </td><td class="right">#define EVLOOP_ONCE    0x01</td></tr>
      <tr><td class="left">/** Do not block: see which events are ready now, run the callbacks</td><td> </td><td class="right">/** Do not block: see which events are ready now, run the callbacks</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 825<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 825<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_base_new() or</td><td> </td><td class="right">  @param eb the event_base structure returned by event_base_new() or</td></tr>
      <tr><td class="left">     event_base_new_with_config()</td><td> </td><td class="right">     event_base_new_with_config()</td></tr>
      <tr><td class="left">  @param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK</td><td> </td><td class="right">  @param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK</td></tr>
      <tr><td class="left">  @return 0 if successful, -1 if an error occurred, or 1 if we exited becau
se</td><td> </td><td class="right">  @return 0 if successful, -1 if an error occurred, or 1 if we exited becau
se</td></tr>
      <tr><td class="left">     no events were pending or active.</td><td> </td><td class="right">     no events were pending or active.</td></tr>
      <tr><td class="left">  @see event_base_loopexit(), event_base_dispatch(), EVLOOP_ONCE,</td><td> </td><td class="right">  @see event_base_loopexit(), event_base_dispatch(), EVLOOP_ONCE,</td></tr>
      <tr><td class="left">     EVLOOP_NONBLOCK</td><td> </td><td class="right">     EVLOOP_NONBLOCK</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock">int event_base_loop(struct event_base *<span class="delete">, int</span>);</td><td> </td><td class="rblock">int event_base_loop(struct event_base *<span class="insert">eb, int flags</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Exit the event loop after the specified time</td><td> </td><td class="right">  Exit the event loop after the specified time</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The next event_base_loop() iteration after the given timer expires will</td><td> </td><td class="right">  The next event_base_loop() iteration after the given timer expires will</td></tr>
      <tr><td class="left">  complete normally (handling all queued events) then exit without</td><td> </td><td class="right">  complete normally (handling all queued events) then exit without</td></tr>
      <tr><td class="left">  blocking for events again.</td><td> </td><td class="right">  blocking for events again.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Subsequent invocations of event_base_loop() will proceed normally.</td><td> </td><td class="right">  Subsequent invocations of event_base_loop() will proceed normally.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @param tv the amount of time after which the loop should terminate,</td><td> </td><td class="right">  @param tv the amount of time after which the loop should terminate,</td></tr>
      <tr><td class="left">    or NULL to exit after running all currently active events.</td><td> </td><td class="right">    or NULL to exit after running all currently active events.</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_base_loopbreak()</td><td> </td><td class="right">  @see event_base_loopbreak()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock">int event_base_loopexit(struct event_base *<span class="delete">, const struct timeval *</span>);</td><td> </td><td class="rblock">int event_base_loopexit(struct event_base *<span class="insert">eb, const struct timeval *tv</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Abort the active event_base_loop() immediately.</td><td> </td><td class="right">  Abort the active event_base_loop() immediately.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event_base_loop() will abort the loop after the next event is completed;</td><td> </td><td class="right">  event_base_loop() will abort the loop after the next event is completed;</td></tr>
      <tr><td class="left">  event_base_loopbreak() is typically invoked from this event's callback.</td><td> </td><td class="right">  event_base_loopbreak() is typically invoked from this event's callback.</td></tr>
      <tr><td class="left">  This behavior is analogous to the "break;" statement.</td><td> </td><td class="right">  This behavior is analogous to the "break;" statement.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Subsequent invocations of event_base_loop() will proceed normally.</td><td> </td><td class="right">  Subsequent invocations of event_base_loop() will proceed normally.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_base_loopexit()</td><td> </td><td class="right">  @see event_base_loopexit()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock">int event_base_loopbreak(struct event_base *);</td><td> </td><td class="rblock">int event_base_loopbreak(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Tell the active event_base_loop() to scan for new events immediately.</td><td> </td><td class="right">  Tell the active event_base_loop() to scan for new events immediately.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Calling this function makes the currently active event_base_loop()</td><td> </td><td class="right">  Calling this function makes the currently active event_base_loop()</td></tr>
      <tr><td class="left">  start the loop over again (scanning for new events) after the current</td><td> </td><td class="right">  start the loop over again (scanning for new events) after the current</td></tr>
      <tr><td class="left">  event callback finishes.  If the event loop is not running, this</td><td> </td><td class="right">  event callback finishes.  If the event loop is not running, this</td></tr>
      <tr><td class="left">  function has no effect.</td><td> </td><td class="right">  function has no effect.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event_base_loopbreak() is typically invoked from this event's callback.</td><td> </td><td class="right">  event_base_loopbreak() is typically invoked from this event's callback.</td></tr>
      <tr><td class="left">  This behavior is analogous to the "continue;" statement.</td><td> </td><td class="right">  This behavior is analogous to the "continue;" statement.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Subsequent invocations of event loop will proceed normally.</td><td> </td><td class="right">  Subsequent invocations of event loop will proceed normally.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_base_loopbreak()</td><td> </td><td class="right">  @see event_base_loopbreak()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock">int event_base_loopcontinue(struct event_base *);</td><td> </td><td class="rblock">int event_base_loopcontinue(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Checks if the event loop was told to exit by event_base_loopexit().</td><td> </td><td class="right">  Checks if the event loop was told to exit by event_base_loopexit().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  This function will return true for an event_base at every point after</td><td> </td><td class="right">  This function will return true for an event_base at every point after</td></tr>
      <tr><td class="left">  event_loopexit() is called, until the event loop is next entered.</td><td> </td><td class="right">  event_loopexit() is called, until the event loop is next entered.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @return true if event_base_loopexit() was called on this event base,</td><td> </td><td class="right">  @return true if event_base_loopexit() was called on this event base,</td></tr>
      <tr><td class="left">    or 0 otherwise</td><td> </td><td class="right">    or 0 otherwise</td></tr>
      <tr><td class="left">  @see event_base_loopexit()</td><td> </td><td class="right">  @see event_base_loopexit()</td></tr>
      <tr><td class="left">  @see event_base_got_break()</td><td> </td><td class="right">  @see event_base_got_break()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock">int event_base_got_exit(struct event_base *);</td><td> </td><td class="rblock">int event_base_got_exit(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Checks if the event loop was told to abort immediately by event_base_loop
break().</td><td> </td><td class="right">  Checks if the event loop was told to abort immediately by event_base_loop
break().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  This function will return true for an event_base at every point after</td><td> </td><td class="right">  This function will return true for an event_base at every point after</td></tr>
      <tr><td class="left">  event_base_loopbreak() is called, until the event loop is next entered.</td><td> </td><td class="right">  event_base_loopbreak() is called, until the event loop is next entered.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @return true if event_base_loopbreak() was called on this event base,</td><td> </td><td class="right">  @return true if event_base_loopbreak() was called on this event base,</td></tr>
      <tr><td class="left">    or 0 otherwise</td><td> </td><td class="right">    or 0 otherwise</td></tr>
      <tr><td class="left">  @see event_base_loopbreak()</td><td> </td><td class="right">  @see event_base_loopbreak()</td></tr>
      <tr><td class="left">  @see event_base_got_exit()</td><td> </td><td class="right">  @see event_base_got_exit()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock">int event_base_got_break(struct event_base *);</td><td> </td><td class="rblock">int event_base_got_break(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @name event flags</td><td> </td><td class="right"> * @name event flags</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Flags to pass to event_new(), event_assign(), event_pending(), and</td><td> </td><td class="right"> * Flags to pass to event_new(), event_assign(), event_pending(), and</td></tr>
      <tr><td class="left"> * anything else with an argument of the form "short events"</td><td> </td><td class="right"> * anything else with an argument of the form "short events"</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">/**@{*/</td><td> </td><td class="right">/**@{*/</td></tr>
      <tr><td class="left">/** Indicates that a timeout has occurred.  It's not necessary to pass</td><td> </td><td class="right">/** Indicates that a timeout has occurred.  It's not necessary to pass</td></tr>
      <tr><td class="left"> * this flag to event_for new()/event_assign() to get a timeout. */</td><td> </td><td class="right"> * this flag to event_for new()/event_assign() to get a timeout. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 1089<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 1089<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  @param events desired events to monitor: bitfield of EV_READ, EV_WRITE,</td><td> </td><td class="right">  @param events desired events to monitor: bitfield of EV_READ, EV_WRITE,</td></tr>
      <tr><td class="left">      EV_SIGNAL, EV_PERSIST, EV_ET.</td><td> </td><td class="right">      EV_SIGNAL, EV_PERSIST, EV_ET.</td></tr>
      <tr><td class="left">  @param callback callback function to be invoked when the event occurs</td><td> </td><td class="right">  @param callback callback function to be invoked when the event occurs</td></tr>
      <tr><td class="left">  @param callback_arg an argument to be passed to the callback function</td><td> </td><td class="right">  @param callback_arg an argument to be passed to the callback function</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @return a newly allocated struct event that must later be freed with</td><td> </td><td class="right">  @return a newly allocated struct event that must later be freed with</td></tr>
      <tr><td class="left">    event_free() or NULL if an error occurred.</td><td> </td><td class="right">    event_free() or NULL if an error occurred.</td></tr>
      <tr><td class="left">  @see event_free(), event_add(), event_del(), event_assign()</td><td> </td><td class="right">  @see event_free(), event_add(), event_del(), event_assign()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock">struct event *event_new(struct event_base *<span class="delete">, evutil_socket_t, short, event_
callback_fn, void *</span>);</td><td> </td><td class="rblock">struct event *event_new(struct event_base *<span class="insert">base, evutil_socket_t fd, short 
events, event_callback_fn callback, void *callback_arg</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Prepare a new, already-allocated event structure to be added.</td><td> </td><td class="right">  Prepare a new, already-allocated event structure to be added.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The function event_assign() prepares the event structure ev to be used</td><td> </td><td class="right">  The function event_assign() prepares the event structure ev to be used</td></tr>
      <tr><td class="left">  in future calls to event_add() and event_del().  Unlike event_new(), it</td><td> </td><td class="right">  in future calls to event_add() and event_del().  Unlike event_new(), it</td></tr>
      <tr><td class="left">  doesn't allocate memory itself: it requires that you have already</td><td> </td><td class="right">  doesn't allocate memory itself: it requires that you have already</td></tr>
      <tr><td class="left">  allocated a struct event, probably on the heap.  Doing this will</td><td> </td><td class="right">  allocated a struct event, probably on the heap.  Doing this will</td></tr>
      <tr><td class="left">  typically make your code depend on the size of the event structure, and</td><td> </td><td class="right">  typically make your code depend on the size of the event structure, and</td></tr>
      <tr><td class="left">  thereby create incompatibility with future versions of Libevent.</td><td> </td><td class="right">  thereby create incompatibility with future versions of Libevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-9" class="change" ><th><small>skipping to change at</small><a href="#part-9"><em> line 1130<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-9"><em> line 1130<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  @param events desired events to monitor; can be EV_READ and/or EV_WRITE</td><td> </td><td class="right">  @param events desired events to monitor; can be EV_READ and/or EV_WRITE</td></tr>
      <tr><td class="left">  @param callback callback function to be invoked when the event occurs</td><td> </td><td class="right">  @param callback callback function to be invoked when the event occurs</td></tr>
      <tr><td class="left">  @param callback_arg an argument to be passed to the callback function</td><td> </td><td class="right">  @param callback_arg an argument to be passed to the callback function</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @return 0 if success, or -1 on invalid arguments.</td><td> </td><td class="right">  @return 0 if success, or -1 on invalid arguments.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @see event_new(), event_add(), event_del(), event_base_once(),</td><td> </td><td class="right">  @see event_new(), event_add(), event_del(), event_base_once(),</td></tr>
      <tr><td class="left">    event_get_struct_event_size()</td><td> </td><td class="right">    event_get_struct_event_size()</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0018"></tr>
      <tr><td class="lblock">int event_assign(struct event *<span class="delete">, struct event_base *, evutil_socket_t, shor
t, event_callback_fn, void *</span>);</td><td> </td><td class="rblock">int event_assign(struct event *<span class="insert">ev, struct event_base *base, evutil_socket_t
 fd, short events, event_callback_fn callback, void *callback_arg</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Deallocate a struct event * returned by event_new().</td><td> </td><td class="right">   Deallocate a struct event * returned by event_new().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   If the event is pending or active, this function makes it non-pending</td><td> </td><td class="right">   If the event is pending or active, this function makes it non-pending</td></tr>
      <tr><td class="left">   and non-active first.</td><td> </td><td class="right">   and non-active first.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void event_free(struct event *);</td><td> </td><td class="right">void event_free(struct event *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-10" class="change" ><th><small>skipping to change at</small><a href="#part-10"><em> line 1207<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-10"><em> line 1207<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  @param events event(s) to monitor; can be any of EV_READ |</td><td> </td><td class="right">  @param events event(s) to monitor; can be any of EV_READ |</td></tr>
      <tr><td class="left">         EV_WRITE, or EV_TIMEOUT</td><td> </td><td class="right">         EV_WRITE, or EV_TIMEOUT</td></tr>
      <tr><td class="left">  @param callback callback function to be invoked when the event occurs</td><td> </td><td class="right">  @param callback callback function to be invoked when the event occurs</td></tr>
      <tr><td class="left">  @param arg an argument to be passed to the callback function</td><td> </td><td class="right">  @param arg an argument to be passed to the callback function</td></tr>
      <tr><td class="left">  @param timeout the maximum amount of time to wait for the event. NULL</td><td> </td><td class="right">  @param timeout the maximum amount of time to wait for the event. NULL</td></tr>
      <tr><td class="left">         makes an EV_READ/EV_WRITE event make forever; NULL makes an</td><td> </td><td class="right">         makes an EV_READ/EV_WRITE event make forever; NULL makes an</td></tr>
      <tr><td class="left">        EV_TIMEOUT event success immediately.</td><td> </td><td class="right">        EV_TIMEOUT event success immediately.</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0019"></tr>
      <tr><td class="lblock">int event_base_once(struct event_base *<span class="delete">, evutil_socket_t, short, event_call
back_fn, void *, const struct timeval *</span>);</td><td> </td><td class="rblock">int event_base_once(struct event_base *<span class="insert">base, evutil_socket_t fd, short even
ts, event_callback_fn callback, void *arg, const struct timeval *timeout</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Add an event to the set of pending events.</td><td> </td><td class="right">  Add an event to the set of pending events.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The function event_add() schedules the execution of the event 'ev' when t
he</td><td> </td><td class="right">  The function event_add() schedules the execution of the event 'ev' when t
he</td></tr>
      <tr><td class="left">  condition specified by event_assign() or event_new() occurs, or when the 
time</td><td> </td><td class="right">  condition specified by event_assign() or event_new() occurs, or when the 
time</td></tr>
      <tr><td class="left">  specified in timeout has elapsed.  If a timeout is NULL, no timeout</td><td> </td><td class="right">  specified in timeout has elapsed.  If a timeout is NULL, no timeout</td></tr>
      <tr><td class="left">  occurs and the function will only be</td><td> </td><td class="right">  occurs and the function will only be</td></tr>
      <tr><td class="left">  called if a matching event occurs.  The event in the</td><td> </td><td class="right">  called if a matching event occurs.  The event in the</td></tr>
      <tr><td class="left">  ev argument must be already initialized by event_assign() or event_new()</td><td> </td><td class="right">  ev argument must be already initialized by event_assign() or event_new()</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-11" class="change" ><th><small>skipping to change at</small><a href="#part-11"><em> line 1257<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-11"><em> line 1257<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The function event_del() will cancel the event in the argument ev.  If th
e</td><td> </td><td class="right">  The function event_del() will cancel the event in the argument ev.  If th
e</td></tr>
      <tr><td class="left">  event has already executed or has never been added the call will have no</td><td> </td><td class="right">  event has already executed or has never been added the call will have no</td></tr>
      <tr><td class="left">  effect.</td><td> </td><td class="right">  effect.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param ev an event struct to be removed from the working set</td><td> </td><td class="right">  @param ev an event struct to be removed from the working set</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_add()</td><td> </td><td class="right">  @see event_add()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0020"></tr>
      <tr><td class="lblock">int event_del(struct event *);</td><td> </td><td class="rblock">int event_del(struct event *<span class="insert">ev</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   As event_del(), but never blocks while the event's callback is running</td><td> </td><td class="right">   As event_del(), but never blocks while the event's callback is running</td></tr>
      <tr><td class="left">   in another thread, even if the event was constructed without the</td><td> </td><td class="right">   in another thread, even if the event was constructed without the</td></tr>
      <tr><td class="left">   EV_FINALIZE flag.</td><td> </td><td class="right">   EV_FINALIZE flag.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int event_del_noblock(struct event *ev);</td><td> </td><td class="right">int event_del_noblock(struct event *ev);</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   As event_del(), but always blocks while the event's callback is running</td><td> </td><td class="right">   As event_del(), but always blocks while the event's callback is running</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-12" class="change" ><th><small>skipping to change at</small><a href="#part-12"><em> line 1467<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-12"><em> line 1467<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  events again, before running less-urgent events.  Less-urgent events</td><td> </td><td class="right">  events again, before running less-urgent events.  Less-urgent events</td></tr>
      <tr><td class="left">  will not have their callbacks run until there are no events more urgent</td><td> </td><td class="right">  will not have their callbacks run until there are no events more urgent</td></tr>
      <tr><td class="left">  than them that want to be active.</td><td> </td><td class="right">  than them that want to be active.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left">  @param npriorities the maximum number of priorities</td><td> </td><td class="right">  @param npriorities the maximum number of priorities</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_priority_set()</td><td> </td><td class="right">  @see event_priority_set()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0021"></tr>
      <tr><td class="lblock">int    event_base_priority_init(struct event_base *<span class="delete">, int</span>);</td><td> </td><td class="rblock">int    event_base_priority_init(struct event_base *<span class="insert">eb, int npriorities</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Get the number of different event priorities.</td><td> </td><td class="right">  Get the number of different event priorities.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left">  @return Number of different event priorities</td><td> </td><td class="right">  @return Number of different event priorities</td></tr>
      <tr><td class="left">  @see event_base_priority_init()</td><td> </td><td class="right">  @see event_base_priority_init()</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int    event_base_get_npriorities(struct event_base *eb);</td><td> </td><td class="right">int    event_base_get_npriorities(struct event_base *eb);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Assign a priority to an event.</td><td> </td><td class="right">  Assign a priority to an event.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param ev an event struct</td><td> </td><td class="right">  @param ev an event struct</td></tr>
      <tr><td class="left">  @param priority the new priority to be assigned</td><td> </td><td class="right">  @param priority the new priority to be assigned</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_priority_init(), event_get_priority()</td><td> </td><td class="right">  @see event_priority_init(), event_get_priority()</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0022"></tr>
      <tr><td class="lblock">int    event_priority_set(struct event *<span class="delete">, int</span>);</td><td> </td><td class="rblock">int    event_priority_set(struct event *<span class="insert">ev, int priority</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Prepare an event_base to use a large number of timeouts with the same</td><td> </td><td class="right">   Prepare an event_base to use a large number of timeouts with the same</td></tr>
      <tr><td class="left">   duration.</td><td> </td><td class="right">   duration.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Libevent's default scheduling algorithm is optimized for having a large</td><td> </td><td class="right">   Libevent's default scheduling algorithm is optimized for having a large</td></tr>
      <tr><td class="left">   number of timeouts with their durations more or less randomly</td><td> </td><td class="right">   number of timeouts with their durations more or less randomly</td></tr>
      <tr><td class="left">   distributed.  But if you have a large number of timeouts that all have</td><td> </td><td class="right">   distributed.  But if you have a large number of timeouts that all have</td></tr>
      <tr><td class="left">   the same duration (for example, if you have a large number of</td><td> </td><td class="right">   the same duration (for example, if you have a large number of</td></tr>
      <tr><td class="left">   connections that all have a 10-second timeout), then you can improve</td><td> </td><td class="right">   connections that all have a 10-second timeout), then you can improve</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-13" class="change" ><th><small>skipping to change at</small><a href="#part-13"><em> line 1557<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-13"><em> line 1557<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   Writes a human-readable description of all inserted and/or active</td><td> </td><td class="right">   Writes a human-readable description of all inserted and/or active</td></tr>
      <tr><td class="left">   events to a provided stdio stream.</td><td> </td><td class="right">   events to a provided stdio stream.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   This is intended for debugging; its format is not guaranteed to be the s
ame</td><td> </td><td class="right">   This is intended for debugging; its format is not guaranteed to be the s
ame</td></tr>
      <tr><td class="left">   between libevent versions.</td><td> </td><td class="right">   between libevent versions.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base An event_base on which to scan the events.</td><td> </td><td class="right">   @param base An event_base on which to scan the events.</td></tr>
      <tr><td class="left">   @param output A stdio file to write on.</td><td> </td><td class="right">   @param output A stdio file to write on.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0023"></tr>
      <tr><td class="lblock">void event_base_dump_events(struct event_base *<span class="delete">, FILE *</span>);</td><td> </td><td class="rblock">void event_base_dump_events(struct event_base *<span class="insert">base, FILE *output</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Activates all pending events for the given fd and event mask.</td><td> </td><td class="right">   Activates all pending events for the given fd and event mask.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   This function activates pending events only.  Events which have not been</td><td> </td><td class="right">   This function activates pending events only.  Events which have not been</td></tr>
      <tr><td class="left">   added will not become active.</td><td> </td><td class="right">   added will not become active.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base the event_base on which to activate the events.</td><td> </td><td class="right">   @param base the event_base on which to activate the events.</td></tr>
      <tr><td class="left">   @param fd An fd to active events on.</td><td> </td><td class="right">   @param fd An fd to active events on.</td></tr>
      <tr><td class="left">   @param events One or more of EV_{READ,WRITE,TIMEOUT}.</td><td> </td><td class="right">   @param events One or more of EV_{READ,WRITE,TIMEOUT}.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-14" class="change" ><th><small>skipping to change at</small><a href="#part-14"><em> line 1579<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-14"><em> line 1579<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void event_base_active_by_fd(struct event_base *base, evutil_socket_t fd, s
hort events);</td><td> </td><td class="right">void event_base_active_by_fd(struct event_base *base, evutil_socket_t fd, s
hort events);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Activates all pending signals with a given signal number</td><td> </td><td class="right">   Activates all pending signals with a given signal number</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   This function activates pending events only.  Events which have not been</td><td> </td><td class="right">   This function activates pending events only.  Events which have not been</td></tr>
      <tr><td class="left">   added will not become active.</td><td> </td><td class="right">   added will not become active.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base the event_base on which to activate the events.</td><td> </td><td class="right">   @param base the event_base on which to activate the events.</td></tr>
      <tr id="diff0024"></tr>
      <tr><td class="lblock">   @param <span class="delete">fd</span> The signal to active events on.</td><td> </td><td class="rblock">   @param <span class="insert">sig</span> The signal to active events on.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void event_base_active_by_signal(struct event_base *base, int sig);</td><td> </td><td class="right">void event_base_active_by_signal(struct event_base *base, int sig);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Callback for iterating events in an event base via event_base_foreach_ev
ent</td><td> </td><td class="right"> * Callback for iterating events in an event base via event_base_foreach_ev
ent</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef int (*event_base_foreach_event_cb)(const struct event_base *, const
 struct event *, void *);</td><td> </td><td class="right">typedef int (*event_base_foreach_event_cb)(const struct event_base *, const
 struct event *, void *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 24 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>24 lines changed or deleted</i></th><th><i> </i></th><th><i>24 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;event_compat.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;event_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_EVENT_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_EVENT_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_EVENT_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_EVENT_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/event_compat.h</td><td> </td><td class="right">/** @file event2/event_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  <span class="delete">Potentially non-threadsafe versions of the functions in event.h: p</span>rovided</td><td> </td><td class="rblock">  <span class="insert">@brief Potentially non-threadsafe versions of the functions in event.h: p
</span>rovided</td></tr>
      <tr><td class="left">  only for backwards compatibility.</td><td> </td><td class="right">  only for backwards compatibility.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  In the oldest versions of Libevent, event_base was not a first-class</td><td> </td><td class="right">  In the oldest versions of Libevent, event_base was not a first-class</td></tr>
      <tr><td class="left">  structure.  Instead, there was a single event base that every function</td><td> </td><td class="right">  structure.  Instead, there was a single event base that every function</td></tr>
      <tr><td class="left">  manipulated.  Later, when separate event bases were added, the old functi
ons</td><td> </td><td class="right">  manipulated.  Later, when separate event bases were added, the old functi
ons</td></tr>
      <tr><td class="left">  that didn't take an event_base argument needed to work by manipulating th
e</td><td> </td><td class="right">  that didn't take an event_base argument needed to work by manipulating th
e</td></tr>
      <tr><td class="left">  "current" event base.  This could lead to thread-safety issues, and obscu
re,</td><td> </td><td class="right">  "current" event base.  This could lead to thread-safety issues, and obscu
re,</td></tr>
      <tr><td class="left">  hard-to-diagnose bugs.</td><td> </td><td class="right">  hard-to-diagnose bugs.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @deprecated All functions in this file are by definition deprecated.</td><td> </td><td class="right">  @deprecated All functions in this file are by definition deprecated.</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;event_struct.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;event_struct.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 129<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 129<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">       void *evcb_arg;</td><td> </td><td class="right">       void *evcb_arg;</td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct event_base;</td><td> </td><td class="right">struct event_base;</td></tr>
      <tr><td class="left">struct event {</td><td> </td><td class="right">struct event {</td></tr>
      <tr><td class="left">       struct event_callback ev_evcallback;</td><td> </td><td class="right">       struct event_callback ev_evcallback;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /* for managing timeouts */</td><td> </td><td class="right">       /* for managing timeouts */</td></tr>
      <tr><td class="left">       union {</td><td> </td><td class="right">       union {</td></tr>
      <tr><td class="left">               TAILQ_ENTRY(event) ev_next_with_common_timeout;</td><td> </td><td class="right">               TAILQ_ENTRY(event) ev_next_with_common_timeout;</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">               <span class="delete">in</span>t min_heap_idx;</td><td> </td><td class="rblock">               <span class="insert">size_</span>t min_heap_idx;</td></tr>
      <tr><td class="left">       } ev_timeout_pos;</td><td> </td><td class="right">       } ev_timeout_pos;</td></tr>
      <tr><td class="left">       evutil_socket_t ev_fd;</td><td> </td><td class="right">       evutil_socket_t ev_fd;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">short ev_events;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       short ev_res;           /* result passed to event callback */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       struct event_base *ev_base;</td><td> </td><td class="right">       struct event_base *ev_base;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       union {</td><td> </td><td class="right">       union {</td></tr>
      <tr><td class="left">               /* used for io events */</td><td> </td><td class="right">               /* used for io events */</td></tr>
      <tr><td class="left">               struct {</td><td> </td><td class="right">               struct {</td></tr>
      <tr><td class="left">                       LIST_ENTRY (event) ev_io_next;</td><td> </td><td class="right">                       LIST_ENTRY (event) ev_io_next;</td></tr>
      <tr><td class="left">                       struct timeval ev_timeout;</td><td> </td><td class="right">                       struct timeval ev_timeout;</td></tr>
      <tr><td class="left">               } ev_io;</td><td> </td><td class="right">               } ev_io;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /* used by signal events */</td><td> </td><td class="right">               /* used by signal events */</td></tr>
      <tr><td class="left">               struct {</td><td> </td><td class="right">               struct {</td></tr>
      <tr><td class="left">                       LIST_ENTRY (event) ev_signal_next;</td><td> </td><td class="right">                       LIST_ENTRY (event) ev_signal_next;</td></tr>
      <tr><td class="left">                       short ev_ncalls;</td><td> </td><td class="right">                       short ev_ncalls;</td></tr>
      <tr><td class="left">                       /* Allows deletes in callback */</td><td> </td><td class="right">                       /* Allows deletes in callback */</td></tr>
      <tr><td class="left">                       short *ev_pncalls;</td><td> </td><td class="right">                       short *ev_pncalls;</td></tr>
      <tr><td class="left">               } ev_signal;</td><td> </td><td class="right">               } ev_signal;</td></tr>
      <tr><td class="left">       } ev_;</td><td> </td><td class="right">       } ev_;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock">       <span class="delete">short ev_events;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       short ev_res;           /* result passed to event callback */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       struct timeval ev_timeout;</td><td> </td><td class="right">       struct timeval ev_timeout;</td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">TAILQ_HEAD (event_list, event);</td><td> </td><td class="right">TAILQ_HEAD (event_list, event);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef EVENT_DEFINED_TQENTRY_</td><td> </td><td class="right">#ifdef EVENT_DEFINED_TQENTRY_</td></tr>
      <tr><td class="left">#undef TAILQ_ENTRY</td><td> </td><td class="right">#undef TAILQ_ENTRY</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef EVENT_DEFINED_TQHEAD_</td><td> </td><td class="right">#ifdef EVENT_DEFINED_TQHEAD_</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 3 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>3 lines changed or deleted</i></th><th><i> </i></th><th><i>4 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;http.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;http.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 46<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 46<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* In case we haven't included the right headers yet. */</td><td> </td><td class="right">/* In case we haven't included the right headers yet. */</td></tr>
      <tr><td class="left">struct evbuffer;</td><td> </td><td class="right">struct evbuffer;</td></tr>
      <tr><td class="left">struct event_base;</td><td> </td><td class="right">struct event_base;</td></tr>
      <tr><td class="left">struct bufferevent;</td><td> </td><td class="right">struct bufferevent;</td></tr>
      <tr><td class="left">struct evhttp_connection;</td><td> </td><td class="right">struct evhttp_connection;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/http.h</td><td> </td><td class="right">/** @file event2/http.h</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"> * Basic support for HTTP serving.</td><td> </td><td class="rblock"> * <span class="insert">@brief </span>Basic support for HTTP serving.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * As Libevent is a library for dealing with event notification and most</td><td> </td><td class="right"> * As Libevent is a library for dealing with event notification and most</td></tr>
      <tr><td class="left"> * interesting applications are networked today, I have often found the</td><td> </td><td class="right"> * interesting applications are networked today, I have often found the</td></tr>
      <tr><td class="left"> * need to write HTTP code.  The following prototypes and definitions provi
de</td><td> </td><td class="right"> * need to write HTTP code.  The following prototypes and definitions provi
de</td></tr>
      <tr><td class="left"> * an application with a minimal interface for making HTTP requests and for</td><td> </td><td class="right"> * an application with a minimal interface for making HTTP requests and for</td></tr>
      <tr><td class="left"> * creating a very simple HTTP server.</td><td> </td><td class="right"> * creating a very simple HTTP server.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Response codes */</td><td> </td><td class="right">/* Response codes */</td></tr>
      <tr><td class="left">#define HTTP_OK                        200     /**&lt; request completed ok */</td><td> </td><td class="right">#define HTTP_OK                        200     /**&lt; request completed ok */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 76<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 76<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define HTTP_INTERNAL           500     /**&lt; internal error */</td><td> </td><td class="right">#define HTTP_INTERNAL           500     /**&lt; internal error */</td></tr>
      <tr><td class="left">#define HTTP_NOTIMPLEMENTED     501     /**&lt; not implemented */</td><td> </td><td class="right">#define HTTP_NOTIMPLEMENTED     501     /**&lt; not implemented */</td></tr>
      <tr><td class="left">#define HTTP_SERVUNAVAIL       503     /**&lt; the server is not available */</td><td> </td><td class="right">#define HTTP_SERVUNAVAIL       503     /**&lt; the server is not available */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct evhttp;</td><td> </td><td class="right">struct evhttp;</td></tr>
      <tr><td class="left">struct evhttp_request;</td><td> </td><td class="right">struct evhttp_request;</td></tr>
      <tr><td class="left">struct evkeyvalq;</td><td> </td><td class="right">struct evkeyvalq;</td></tr>
      <tr><td class="left">struct evhttp_bound_socket;</td><td> </td><td class="right">struct evhttp_bound_socket;</td></tr>
      <tr><td class="left">struct evconnlistener;</td><td> </td><td class="right">struct evconnlistener;</td></tr>
      <tr><td class="left">struct evdns_base;</td><td> </td><td class="right">struct evdns_base;</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct evhttp_ext_method;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a new HTTP server.</td><td> </td><td class="right"> * Create a new HTTP server.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param base (optional) the event base to receive the HTTP events</td><td> </td><td class="right"> * @param base (optional) the event base to receive the HTTP events</td></tr>
      <tr><td class="left"> * @return a pointer to a newly initialized evhttp server structure or NULL</td><td> </td><td class="right"> * @return a pointer to a newly initialized evhttp server structure or NULL</td></tr>
      <tr><td class="left"> *   on error</td><td> </td><td class="right"> *   on error</td></tr>
      <tr><td class="left"> * @see evhttp_free()</td><td> </td><td class="right"> * @see evhttp_free()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 249<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 250<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  server, and passed to user callbacks.</td><td> </td><td class="right">  server, and passed to user callbacks.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  If not supported they will generate a "405 Method not allowed" response.</td><td> </td><td class="right">  If not supported they will generate a "405 Method not allowed" response.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  By default this includes the following methods: GET, POST, HEAD, PUT, DEL
ETE</td><td> </td><td class="right">  By default this includes the following methods: GET, POST, HEAD, PUT, DEL
ETE</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param http the http server on which to set the methods</td><td> </td><td class="right">  @param http the http server on which to set the methods</td></tr>
      <tr><td class="left">  @param methods bit mask constructed from evhttp_cmd_type values</td><td> </td><td class="right">  @param methods bit mask constructed from evhttp_cmd_type values</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock">void evhttp_set_allowed_methods(struct evhttp* http, <span class="delete">ev_uint16_t</span> methods);</td><td> </td><td class="rblock">void evhttp_set_allowed_methods(struct evhttp* http, <span class="insert">ev_uint32_t</span> methods);</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef int (*evhttp_ext_method_cb)(struct evhttp_ext_method *);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Sets the callback function which allows HTTP extended methods</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  to be supported by this server.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  The callback should :</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - if method field is NULL : set method field according to type field</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - else : set type and flags fields according to method string</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - return 0 for success (known method / type)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - return -1 for error (unknown method / type)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  evhttp_set_allowed_methods still needs to be called.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param http the http server on which to add support to the methods</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param cmp the extended method callback</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @see evhttp_ext_method</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_ext_method_cmp(struct evhttp *http, evhttp_ext_method_cb cm</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">p);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Set a callback for a specified URI</td><td> </td><td class="right">   Set a callback for a specified URI</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param http the http sever on which to set the callback</td><td> </td><td class="right">   @param http the http sever on which to set the callback</td></tr>
      <tr><td class="left">   @param path the path for which to invoke the callback</td><td> </td><td class="right">   @param path the path for which to invoke the callback</td></tr>
      <tr><td class="left">   @param cb the callback function that gets invoked on requesting path</td><td> </td><td class="right">   @param cb the callback function that gets invoked on requesting path</td></tr>
      <tr><td class="left">   @param cb_arg an additional context argument for the callback</td><td> </td><td class="right">   @param cb_arg an additional context argument for the callback</td></tr>
      <tr><td class="left">   @return 0 on success, -1 if the callback existed already, -2 on failure</td><td> </td><td class="right">   @return 0 on success, -1 if the callback existed already, -2 on failure</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 302<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 323<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param http the evhttp server object for which to set the callback</td><td> </td><td class="right">   @param http the evhttp server object for which to set the callback</td></tr>
      <tr><td class="left">   @param cb the callback to invoke for incoming connections</td><td> </td><td class="right">   @param cb the callback to invoke for incoming connections</td></tr>
      <tr><td class="left">   @param arg an context argument for the callback</td><td> </td><td class="right">   @param arg an context argument for the callback</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_set_bevcb(struct evhttp *http,</td><td> </td><td class="right">void evhttp_set_bevcb(struct evhttp *http,</td></tr>
      <tr><td class="left">    struct bufferevent *(*cb)(struct event_base *, void *), void *arg);</td><td> </td><td class="right">    struct bufferevent *(*cb)(struct event_base *, void *), void *arg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">   <span class="insert">Set a callback which allows the user to note or throttle incoming reques</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   The requests are not populated with HTTP level information. They</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   are just associated to a connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   If the callback returns -1, the associated connection is terminated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   and the request is closed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param http the evhttp server object for which to set the callback</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param cb the callback to invoke for incoming connections</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param arg an context argument for the callback</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_newreqcb(struct evhttp *http,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int (*cb)(struct evhttp_request*, void *), void *arg);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left">   Adds a virtual host to the http server.</td><td> </td><td class="right">   Adds a virtual host to the http server.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   A virtual host is a newly initialized evhttp object that has request</td><td> </td><td class="right">   A virtual host is a newly initialized evhttp object that has request</td></tr>
      <tr><td class="left">   callbacks set on it via evhttp_set_cb() or evhttp_set_gencb().  It</td><td> </td><td class="right">   callbacks set on it via evhttp_set_cb() or evhttp_set_gencb().  It</td></tr>
      <tr><td class="left">   most not have any listing sockets associated with it.</td><td> </td><td class="right">   most not have any listing sockets associated with it.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   If the virtual host has not been removed by the time that evhttp_free()</td><td> </td><td class="right">   If the virtual host has not been removed by the time that evhttp_free()</td></tr>
      <tr><td class="left">   is called on the main http server, it will be automatically freed, too.</td><td> </td><td class="right">   is called on the main http server, it will be automatically freed, too.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   It is possible to have hierarchical vhosts.  For example: A vhost</td><td> </td><td class="right">   It is possible to have hierarchical vhosts.  For example: A vhost</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 363<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 401<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   @param alias the alias to remove</td><td> </td><td class="right">   @param alias the alias to remove</td></tr>
      <tr><td class="left">   @see evhttp_add_server_alias()</td><td> </td><td class="right">   @see evhttp_add_server_alias()</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_remove_server_alias(struct evhttp *http, const char *alias);</td><td> </td><td class="right">int evhttp_remove_server_alias(struct evhttp *http, const char *alias);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set the timeout for an HTTP request.</td><td> </td><td class="right"> * Set the timeout for an HTTP request.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param http an evhttp object</td><td> </td><td class="right"> * @param http an evhttp object</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"> * @param <span class="delete">timeout_in_secs</span> the timeout, in seconds</td><td> </td><td class="rblock"> * @param <span class="insert">timeout</span> the timeout, in seconds</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* @see evhttp_set_timeout_tv()</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock">void evhttp_set_timeout(struct evhttp *http, int timeout<span class="delete">_in_secs</span>);</td><td> </td><td class="rblock">void evhttp_set_timeout(struct evhttp *http, int timeout);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"> * Set <span class="delete">th</span>e timeout for an HTTP request.</td><td> </td><td class="rblock"> * Set <span class="insert">read and writ</span>e timeout for an HTTP request.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param http an evhttp object</td><td> </td><td class="right"> * @param http an evhttp object</td></tr>
      <tr><td class="left"> * @param tv the timeout, or NULL</td><td> </td><td class="right"> * @param tv the timeout, or NULL</td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * For more precise control:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_set_read_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_set_write_timeout_tv()</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_set_timeout_tv(struct evhttp *http, const struct timeval* tv);</td><td> </td><td class="right">void evhttp_set_timeout_tv(struct evhttp *http, const struct timeval* tv);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Set read timeout for an HTTP request.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param http an evhttp object</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_read_timeout_tv(struct evhttp *http, const struct timeval* </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Set write timeout for an HTTP request.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param http an evhttp object</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_write_timeout_tv(struct evhttp *http, const struct timeval*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Read all the clients body, and only after this respond with an error if 
the</td><td> </td><td class="right">/* Read all the clients body, and only after this respond with an error if 
the</td></tr>
      <tr><td class="left"> * clients body exceed max_body_size */</td><td> </td><td class="right"> * clients body exceed max_body_size */</td></tr>
      <tr><td class="left">#define EVHTTP_SERVER_LINGERING_CLOSE  0x0001</td><td> </td><td class="right">#define EVHTTP_SERVER_LINGERING_CLOSE  0x0001</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set connection flags for HTTP server.</td><td> </td><td class="right"> * Set connection flags for HTTP server.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see EVHTTP_SERVER_*</td><td> </td><td class="right"> * @see EVHTTP_SERVER_*</td></tr>
      <tr><td class="left"> * @return 0 on success, otherwise non zero (for example if flag doesn't</td><td> </td><td class="right"> * @return 0 on success, otherwise non zero (for example if flag doesn't</td></tr>
      <tr><td class="left"> * supported).</td><td> </td><td class="right"> * supported).</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 467<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 528<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   Send another data chunk as part of an ongoing chunked reply.</td><td> </td><td class="right">   Send another data chunk as part of an ongoing chunked reply.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   The reply chunk consists of the data in databuf.  After calling</td><td> </td><td class="right">   The reply chunk consists of the data in databuf.  After calling</td></tr>
      <tr><td class="left">   evhttp_send_reply_chunk() databuf will be empty, but the buffer is</td><td> </td><td class="right">   evhttp_send_reply_chunk() databuf will be empty, but the buffer is</td></tr>
      <tr><td class="left">   still owned by the caller and needs to be deallocated by the caller</td><td> </td><td class="right">   still owned by the caller and needs to be deallocated by the caller</td></tr>
      <tr><td class="left">   if necessary.</td><td> </td><td class="right">   if necessary.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param req a request object</td><td> </td><td class="right">   @param req a request object</td></tr>
      <tr><td class="left">   @param databuf the data chunk to send as part of the reply.</td><td> </td><td class="right">   @param databuf the data chunk to send as part of the reply.</td></tr>
      <tr><td class="left">   @param cb callback funcion</td><td> </td><td class="right">   @param cb callback funcion</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock">   @param call back's argument.</td><td> </td><td class="rblock">   @param <span class="insert">arg </span>call back's argument.</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock">void evhttp_send_reply_chunk_with_cb(struct evhttp_request *<span class="delete">, struct evbuff
er *</span>,</td><td> </td><td class="rblock">void evhttp_send_reply_chunk_with_cb(struct evhttp_request *<span class="insert">req, struct evb
uffer *databuf</span>,</td></tr>
      <tr><td class="left">    void (*cb)(struct evhttp_connection *, void *), void *arg);</td><td> </td><td class="right">    void (*cb)(struct evhttp_connection *, void *), void *arg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Complete a chunked reply, freeing the request as appropriate.</td><td> </td><td class="right">   Complete a chunked reply, freeing the request as appropriate.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param req a request object</td><td> </td><td class="right">   @param req a request object</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_send_reply_end(struct evhttp_request *req);</td><td> </td><td class="right">void evhttp_send_reply_end(struct evhttp_request *req);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> * Interfaces for making requests</td><td> </td><td class="right"> * Interfaces for making requests</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The different request types supported by evhttp.  These are as specifie
d</td><td> </td><td class="right">/** The different request types supported by evhttp.  These are as specifie
d</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock"> * in RFC2616, except <span class="delete">for</span> PATCH which is specified by <span class="delete">RFC5789.</span></td><td> </td><td class="rblock"> * in RFC2616, except <span class="insert">for:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * -</span> PATCH which is specified by <span class="insert">RFC5789</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - PROPFIND, PROPPATCH, MKCOL, LOCK, UNLOCK, COPY, MOVE</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   which are specified by RFC4918</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * By default, only some of these methods are accepted and passed to user</td><td> </td><td class="right"> * By default, only some of these methods are accepted and passed to user</td></tr>
      <tr><td class="left"> * callbacks; use evhttp_set_allowed_methods() to change which methods</td><td> </td><td class="right"> * callbacks; use evhttp_set_allowed_methods() to change which methods</td></tr>
      <tr><td class="left"> * are allowed.</td><td> </td><td class="right"> * are allowed.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">enum evhttp_cmd_type {</td><td> </td><td class="right">enum evhttp_cmd_type {</td></tr>
      <tr><td class="left">       EVHTTP_REQ_GET     = 1 &lt;&lt; 0,</td><td> </td><td class="right">       EVHTTP_REQ_GET     = 1 &lt;&lt; 0,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_POST    = 1 &lt;&lt; 1,</td><td> </td><td class="right">       EVHTTP_REQ_POST    = 1 &lt;&lt; 1,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_HEAD    = 1 &lt;&lt; 2,</td><td> </td><td class="right">       EVHTTP_REQ_HEAD    = 1 &lt;&lt; 2,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_PUT     = 1 &lt;&lt; 3,</td><td> </td><td class="right">       EVHTTP_REQ_PUT     = 1 &lt;&lt; 3,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_DELETE  = 1 &lt;&lt; 4,</td><td> </td><td class="right">       EVHTTP_REQ_DELETE  = 1 &lt;&lt; 4,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_OPTIONS = 1 &lt;&lt; 5,</td><td> </td><td class="right">       EVHTTP_REQ_OPTIONS = 1 &lt;&lt; 5,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_TRACE   = 1 &lt;&lt; 6,</td><td> </td><td class="right">       EVHTTP_REQ_TRACE   = 1 &lt;&lt; 6,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_CONNECT = 1 &lt;&lt; 7,</td><td> </td><td class="right">       EVHTTP_REQ_CONNECT = 1 &lt;&lt; 7,</td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock">       EVHTTP_REQ_PATCH   = 1 &lt;&lt; <span class="delete">8</span></td><td> </td><td class="rblock">       EVHTTP_REQ_PATCH   = 1 &lt;&lt; <span class="insert">8,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_PROPFIND= 1 &lt;&lt; 9,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_PROPPATCH=1 &lt;&lt; 10,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_MKCOL   = 1 &lt;&lt; 11,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_LOCK    = 1 &lt;&lt; 12,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_UNLOCK  = 1 &lt;&lt; 13,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_COPY    = 1 &lt;&lt; 14,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_MOVE    = 1 &lt;&lt; 15,</span></td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_REQ_MAX EVHTTP_REQ_MOVE</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @brief stucture that is passed to (and modified by) the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * extended method callback function</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_set_ext_method_cmp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_connection_set_ext_method_cmp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct evhttp_ext_method {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const char *method;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ev_uint32_t type;       /* @see enum evhttp_cmd_type */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ev_uint16_t flags;      /* Available flag : EVHTTP_METHOD_HAS_BODY *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">};</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_METHOD_HAS_BODY 0x0001</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** a request object can represent either a request or a reply */</td><td> </td><td class="right">/** a request object can represent either a request or a reply */</td></tr>
      <tr><td class="left">enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };</td><td> </td><td class="right">enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create and return a connection object that can be used to for making HTT
P</td><td> </td><td class="right"> * Create and return a connection object that can be used to for making HTT
P</td></tr>
      <tr><td class="left"> * requests.  The connection object tries to resolve address and establish 
the</td><td> </td><td class="right"> * requests.  The connection object tries to resolve address and establish 
the</td></tr>
      <tr><td class="left"> * connection when it is given an http request object.</td><td> </td><td class="right"> * connection when it is given an http request object.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Connection also has default timeouts for the following events:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - connect HTTP_CONNECT_TIMEOUT, which is 45 seconds</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - read    HTTP_READ_TIMEOUT which is 50 seconds</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - write   HTTP_WRITE_TIMEOUT, which is 50 seconds</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="left"> * @param base the event_base to use for handling the connection</td><td> </td><td class="right"> * @param base the event_base to use for handling the connection</td></tr>
      <tr><td class="left"> * @param dnsbase the dns_base to use for resolving host names; if not</td><td> </td><td class="right"> * @param dnsbase the dns_base to use for resolving host names; if not</td></tr>
      <tr><td class="left"> *     specified host name resolution will block.</td><td> </td><td class="right"> *     specified host name resolution will block.</td></tr>
      <tr><td class="left"> * @param bev a bufferevent to use for connecting to the server; if NULL, a</td><td> </td><td class="right"> * @param bev a bufferevent to use for connecting to the server; if NULL, a</td></tr>
      <tr><td class="left"> *     socket-based bufferevent will be created.  This buffrevent will be f
reed</td><td> </td><td class="right"> *     socket-based bufferevent will be created.  This buffrevent will be f
reed</td></tr>
      <tr><td class="left"> *     when the connection closes.  It must have no fd set on it.</td><td> </td><td class="right"> *     when the connection closes.  It must have no fd set on it.</td></tr>
      <tr><td class="left"> * @param address the address to which to connect</td><td> </td><td class="right"> * @param address the address to which to connect</td></tr>
      <tr><td class="left"> * @param port the port to connect to</td><td> </td><td class="right"> * @param port the port to connect to</td></tr>
      <tr><td class="left"> * @return an evhttp_connection object that can be used for making requests
 or</td><td> </td><td class="right"> * @return an evhttp_connection object that can be used for making requests
 or</td></tr>
      <tr><td class="left"> *   NULL on error</td><td> </td><td class="right"> *   NULL on error</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 690<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 783<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * evhttp_request_free() is explicitly called by the user.</td><td> </td><td class="right"> * evhttp_request_free() is explicitly called by the user.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_request_own(struct evhttp_request *req);</td><td> </td><td class="right">void evhttp_request_own(struct evhttp_request *req);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Returns 1 if the request is owned by the user */</td><td> </td><td class="right">/** Returns 1 if the request is owned by the user */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_request_is_owned(struct evhttp_request *req);</td><td> </td><td class="right">int evhttp_request_is_owned(struct evhttp_request *req);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Sets extended method cmp callback for this http connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_set_ext_method_cmp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_connection_set_ext_method_cmp(struct evhttp_connection *evcon,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       evhttp_ext_method_cb cmp);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Returns the connection object associated with the request or NULL</td><td> </td><td class="right"> * Returns the connection object associated with the request or NULL</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The user needs to either free the request explicitly or call</td><td> </td><td class="right"> * The user needs to either free the request explicitly or call</td></tr>
      <tr><td class="left"> * evhttp_send_reply_end().</td><td> </td><td class="right"> * evhttp_send_reply_end().</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evhttp_connection *evhttp_request_get_connection(struct evhttp_reque
st *req);</td><td> </td><td class="right">struct evhttp_connection *evhttp_request_get_connection(struct evhttp_reque
st *req);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Returns the underlying event_base for this connection</td><td> </td><td class="right"> * Returns the underlying event_base for this connection</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 734<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 836<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/** sets the ip address from which http connections are made */</td><td> </td><td class="right">/** sets the ip address from which http connections are made */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_local_address(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_local_address(struct evhttp_connection *evcon,</td></tr>
      <tr><td class="left">    const char *address);</td><td> </td><td class="right">    const char *address);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** sets the local port from which http connections are made */</td><td> </td><td class="right">/** sets the local port from which http connections are made */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_local_port(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_local_port(struct evhttp_connection *evcon,</td></tr>
      <tr><td class="left">    ev_uint16_t port);</td><td> </td><td class="right">    ev_uint16_t port);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock">/** Sets the timeout <span class="delete">in seconds</span> for <span class="delete">events related to</span> this <span class="delete">connection</span> */</td><td> </td><td class="rblock">/**</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> Sets the timeout for this <span class="insert">connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_connection_set_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_timeout(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_timeout(struct evhttp_connection *evcon,</td></tr>
      <tr id="diff0018"></tr>
      <tr><td class="lblock">    int timeout<span class="delete">_in_secs</span>);</td><td> </td><td class="rblock">    int timeout);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0019"></tr>
      <tr><td class="lblock">/** Sets the timeout for <span class="delete">events related to</span> this <span class="delete">connection.  Takes a struct</span></td><td> </td><td class="rblock">/**</td></tr>
      <tr><td class="lblock"> * <span class="delete">timeval.</span> */</td><td> </td><td class="rblock"> <span class="insert">*</span> Sets the timeout for this <span class="insert">connection for the following events:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - read,  if tv==NULL then it uses default timeout (HTTP_READ_TIMEOUT)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - write, if tv==NULL then it uses default timeout (HTTP_WRITE_TIMEOUT)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * But it does not adjust timeout for the "connect" (for historical reasons</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * For more precise control:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_connection_set_connect_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_connection_set_read_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">@see evhttp_connection_set_write_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_timeout_tv(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_timeout_tv(struct evhttp_connection *evcon,</td></tr>
      <tr><td class="left">    const struct timeval *tv);</td><td> </td><td class="right">    const struct timeval *tv);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0020"></tr>
      <tr><td class="lblock">/** Sets the delay before retrying requests on this connection. This is <span class="delete">onl</span></td><td> </td><td class="rblock">/**</td></tr>
      <tr><td class="lblock"><span class="delete">y</span></td><td> </td><td class="rblock"> <span class="insert">* Sets the connect timeout for this connection</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> used if evhttp_connection_set_retries is used to make the number of <span class="delete">retr</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"><span class="delete">ies</span></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> at least one. Each retry after the first is twice as <span class="delete">long</span> as the one <span class="delete">bef</span></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"><span class="delete">ore</span></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> it. */</td><td> </td><td class="rblock"><span class="insert">void evhttp_connection_set_connect_timeout_tv(struct evhttp_connection *evc</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">on,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const struct timeval *tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Sets the read timeout for this connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_connection_set_read_timeout_tv(struct evhttp_connection *evcon,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const struct timeval *tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Sets the write timeout for this connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_connection_set_write_timeout_tv(struct evhttp_connection *evcon</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const struct timeval *tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> Sets the delay before retrying requests on this connection.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> This is <span class="insert">only</span> used if evhttp_connection_set_retries is used to make the</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> number of <span class="insert">retries</span> at least one. Each retry after the first is twice as <span class="insert">l</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ong</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> as the one <span class="insert">before</span> it.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Default delay is HTTP_INITIAL_RETRY_TIMEOUT, which is 2 seconds.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_initial_retry_tv(struct evhttp_connection *evcon
,</td><td> </td><td class="right">void evhttp_connection_set_initial_retry_tv(struct evhttp_connection *evcon
,</td></tr>
      <tr><td class="left">    const struct timeval *tv);</td><td> </td><td class="right">    const struct timeval *tv);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Sets the retry limit for this connection - -1 repeats indefinitely */</td><td> </td><td class="right">/** Sets the retry limit for this connection - -1 repeats indefinitely */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_retries(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_retries(struct evhttp_connection *evcon,</td></tr>
      <tr><td class="left">    int retry_max);</td><td> </td><td class="right">    int retry_max);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Set a callback for connection close. */</td><td> </td><td class="right">/** Set a callback for connection close. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-9" class="change" ><th><small>skipping to change at</small><a href="#part-9"><em> line 988<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-9"><em> line 1138<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   @deprecated This function is deprecated as of Libevent 2.0.9.  Use</td><td> </td><td class="right">   @deprecated This function is deprecated as of Libevent 2.0.9.  Use</td></tr>
      <tr><td class="left">     evhttp_uri_parse and evhttp_parse_query_str instead.</td><td> </td><td class="right">     evhttp_uri_parse and evhttp_parse_query_str instead.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param uri the request URI</td><td> </td><td class="right">   @param uri the request URI</td></tr>
      <tr><td class="left">   @param headers the head of the evkeyval queue</td><td> </td><td class="right">   @param headers the head of the evkeyval queue</td></tr>
      <tr><td class="left">   @return 0 on success, -1 on failure</td><td> </td><td class="right">   @return 0 on success, -1 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_parse_query(const char *uri, struct evkeyvalq *headers);</td><td> </td><td class="right">int evhttp_parse_query(const char *uri, struct evkeyvalq *headers);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0021"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @see evhttp_parse_query_str_flags() */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evhttp_parse_query_str(const char *uri, struct evkeyvalq *headers);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Tolerate queries that are not standard conformant.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Here are some examples:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - test=123&amp;test2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   with with this flag test2 will be present in the output headers</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - test=123&amp;&amp;test2=1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   will parse the query with this flag</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - test=123&amp;=456&amp;test2=1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   will parse the queyr with this flag, however there won't be empty key</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   present</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_URI_QUERY_NONCONFORMANT 0x01</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Prefer last value over the first from query args</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Example: test=123&amp;test=456</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Without: test=123</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * With   : test=456</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_URI_QUERY_LAST_VAL 0x02</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Helper function to parse out arguments from the query portion of an</td><td> </td><td class="right">   Helper function to parse out arguments from the query portion of an</td></tr>
      <tr><td class="left">   HTTP URI.</td><td> </td><td class="right">   HTTP URI.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Parsing a query string like</td><td> </td><td class="right">   Parsing a query string like</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">     q=test&amp;s=some+thing</td><td> </td><td class="right">     q=test&amp;s=some+thing</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   will result in two entries in the key value queue.</td><td> </td><td class="right">   will result in two entries in the key value queue.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   The first entry is: key="q", value="test"</td><td> </td><td class="right">   The first entry is: key="q", value="test"</td></tr>
      <tr><td class="left">   The second entry is: key="s", value="some thing"</td><td> </td><td class="right">   The second entry is: key="s", value="some thing"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0022"></tr>
      <tr><td class="lblock">   @param <span class="delete">query_parse</span> the query portion of the URI</td><td> </td><td class="rblock">   @param <span class="insert">uri</span> the query portion of the URI</td></tr>
      <tr><td class="left">   @param headers the head of the evkeyval queue</td><td> </td><td class="right">   @param headers the head of the evkeyval queue</td></tr>
      <tr id="diff0023"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param flags one or more of EVHTTP_URI_QUERY_*</span></td></tr>
      <tr><td class="left">   @return 0 on success, -1 on failure</td><td> </td><td class="right">   @return 0 on success, -1 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0024"></tr>
      <tr><td class="lblock">int evhttp_parse_query_str<span class="delete">(const char *uri, struct evkeyvalq *header</span>s);</td><td> </td><td class="rblock">int evhttp_parse_query_str<span class="insert">_flags(const char *uri, struct evkeyvalq *headers
, unsigned flag</span>s);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Escape HTML character entities in a string.</td><td> </td><td class="right"> * Escape HTML character entities in a string.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Replaces &lt;, &gt;, ", ' and &amp; with &amp;lt;, &amp;gt;, &amp;quot;,</td><td> </td><td class="right"> * Replaces &lt;, &gt;, ", ' and &amp; with &amp;lt;, &amp;gt;, &amp;quot;,</td></tr>
      <tr><td class="left"> * &amp;#039; and &amp;amp; correspondingly.</td><td> </td><td class="right"> * &amp;#039; and &amp;amp; correspondingly.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The returned string needs to be freed by the caller.</td><td> </td><td class="right"> * The returned string needs to be freed by the caller.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param html an unescaped HTML string</td><td> </td><td class="right"> * @param html an unescaped HTML string</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 24 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>22 lines changed or deleted</i></th><th><i> </i></th><th><i>206 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;http_compat.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;http_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_HTTP_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_HTTP_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_HTTP_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_HTTP_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/http_compat.h</td><td> </td><td class="right">/** @file event2/http_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  <span class="delete">Potentially non-threadsafe versions of the functions in http.h: pr</span>ovided</td><td> </td><td class="rblock">  <span class="insert">@brief Potentially non-threadsafe versions of the functions in http.h: pr
</span>ovided</td></tr>
      <tr><td class="left">  only for backwards compatibility.</td><td> </td><td class="right">  only for backwards compatibility.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left">#ifdef EVENT__HAVE_SYS_TYPES_H</td><td> </td><td class="right">#ifdef EVENT__HAVE_SYS_TYPES_H</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;listener.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;listener.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 41<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 41<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event.h&gt;</td><td> </td><td class="right">#include &lt;event2/event.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct sockaddr;</td><td> </td><td class="right">struct sockaddr;</td></tr>
      <tr><td class="left">struct evconnlistener;</td><td> </td><td class="right">struct evconnlistener;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"><span class="insert">/**@file event2/listener.h</span></td></tr>
      <tr><td class="lblock">   A callback that we invoke when a listener has a new connection.</td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @brief</span> A callback that we invoke when a listener has a new connection.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param listener The evconnlistener</td><td> </td><td class="right">   @param listener The evconnlistener</td></tr>
      <tr><td class="left">   @param fd The new file descriptor</td><td> </td><td class="right">   @param fd The new file descriptor</td></tr>
      <tr><td class="left">   @param addr The source address of the connection</td><td> </td><td class="right">   @param addr The source address of the connection</td></tr>
      <tr><td class="left">   @param socklen The length of addr</td><td> </td><td class="right">   @param socklen The length of addr</td></tr>
      <tr><td class="left">   @param user_arg the pointer passed to evconnlistener_new()</td><td> </td><td class="right">   @param user_arg the pointer passed to evconnlistener_new()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef void (*evconnlistener_cb)(struct evconnlistener *, evutil_socket_t,
 struct sockaddr *, int socklen, void *);</td><td> </td><td class="right">typedef void (*evconnlistener_cb)(struct evconnlistener *, evutil_socket_t,
 struct sockaddr *, int socklen, void *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 146<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 147<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   on a given address.</td><td> </td><td class="right">   on a given address.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base The event base to associate the listener with.</td><td> </td><td class="right">   @param base The event base to associate the listener with.</td></tr>
      <tr><td class="left">   @param cb A callback to be invoked when a new connection arrives. If the</td><td> </td><td class="right">   @param cb A callback to be invoked when a new connection arrives. If the</td></tr>
      <tr><td class="left">      callback is NULL, the listener will be treated as disabled until the</td><td> </td><td class="right">      callback is NULL, the listener will be treated as disabled until the</td></tr>
      <tr><td class="left">      callback is set.</td><td> </td><td class="right">      callback is set.</td></tr>
      <tr><td class="left">   @param ptr A user-supplied pointer to give to the callback.</td><td> </td><td class="right">   @param ptr A user-supplied pointer to give to the callback.</td></tr>
      <tr><td class="left">   @param flags Any number of LEV_OPT_* flags</td><td> </td><td class="right">   @param flags Any number of LEV_OPT_* flags</td></tr>
      <tr><td class="left">   @param backlog Passed to the listen() call to determine the length of th
e</td><td> </td><td class="right">   @param backlog Passed to the listen() call to determine the length of th
e</td></tr>
      <tr><td class="left">      acceptable connection backlog.  Set to -1 for a reasonable default.</td><td> </td><td class="right">      acceptable connection backlog.  Set to -1 for a reasonable default.</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock">   @param <span class="delete">addr</span> The address to listen for connections on.</td><td> </td><td class="rblock">   @param <span class="insert">sa</span> The address to listen for connections on.</td></tr>
      <tr><td class="left">   @param socklen The length of the address.</td><td> </td><td class="right">   @param socklen The length of the address.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evconnlistener *evconnlistener_new_bind(struct event_base *base,</td><td> </td><td class="right">struct evconnlistener *evconnlistener_new_bind(struct event_base *base,</td></tr>
      <tr><td class="left">    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,</td><td> </td><td class="right">    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,</td></tr>
      <tr><td class="left">    const struct sockaddr *sa, int socklen);</td><td> </td><td class="right">    const struct sockaddr *sa, int socklen);</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Disable and deallocate an evconnlistener.</td><td> </td><td class="right">   Disable and deallocate an evconnlistener.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 2 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>3 lines changed or deleted</i></th><th><i> </i></th><th><i>4 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;rpc.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;rpc.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 38<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 38<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define EVENT2_RPC_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_RPC_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* For int types. */</td><td> </td><td class="right">/* For int types. */</td></tr>
      <tr><td class="left">#include &lt;event2/util.h&gt;</td><td> </td><td class="right">#include &lt;event2/util.h&gt;</td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">/** @file rpc.h</td><td> </td><td class="rblock">/** @file <span class="insert">event2/</span>rpc.h</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"> * <span class="delete">This header files provides basic support for an RPC server and cl</span>ient.</td><td> </td><td class="rblock"> * <span class="insert">@brief This header files provides basic support for an RPC server and cl
</span>ient.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * To support RPCs in a server, every supported RPC command needs to be</td><td> </td><td class="right"> * To support RPCs in a server, every supported RPC command needs to be</td></tr>
      <tr><td class="left"> * defined and registered.</td><td> </td><td class="right"> * defined and registered.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * EVRPC_HEADER(SendCommand, Request, Reply);</td><td> </td><td class="right"> * EVRPC_HEADER(SendCommand, Request, Reply);</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> *  SendCommand is the name of the RPC command.</td><td> </td><td class="right"> *  SendCommand is the name of the RPC command.</td></tr>
      <tr><td class="left"> *  Request is the name of a structure generated by event_rpcgen.py.</td><td> </td><td class="right"> *  Request is the name of a structure generated by event_rpcgen.py.</td></tr>
      <tr><td class="left"> *    It contains all parameters relating to the SendCommand RPC.  The</td><td> </td><td class="right"> *    It contains all parameters relating to the SendCommand RPC.  The</td></tr>
      <tr><td class="left"> *    server needs to fill in the Reply structure.</td><td> </td><td class="right"> *    server needs to fill in the Reply structure.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 172<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 172<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">struct evrpc_hook_meta;</td><td> </td><td class="right">struct evrpc_hook_meta;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Creates the definitions and prototypes for an RPC</td><td> </td><td class="right">/** Creates the definitions and prototypes for an RPC</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * You need to use EVRPC_HEADER to create structures and function prototype
s</td><td> </td><td class="right"> * You need to use EVRPC_HEADER to create structures and function prototype
s</td></tr>
      <tr><td class="left"> * needed by the server and client implementation.  The structures have to 
be</td><td> </td><td class="right"> * needed by the server and client implementation.  The structures have to 
be</td></tr>
      <tr><td class="left"> * defined in an .rpc file and converted to source code via event_rpcgen.py</td><td> </td><td class="right"> * defined in an .rpc file and converted to source code via event_rpcgen.py</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param rpcname the name of the RPC</td><td> </td><td class="right"> * @param rpcname the name of the RPC</td></tr>
      <tr><td class="left"> * @param reqstruct the name of the RPC request structure</td><td> </td><td class="right"> * @param reqstruct the name of the RPC request structure</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"> * @param r<span class="delete">e</span>plystruct the name of the RPC reply structure</td><td> </td><td class="rblock"> * @param rplystruct the name of the RPC reply structure</td></tr>
      <tr><td class="left"> * @see EVRPC_GENERATE()</td><td> </td><td class="right"> * @see EVRPC_GENERATE()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVRPC_HEADER(rpcname, reqstruct, rplystruct) \</td><td> </td><td class="right">#define EVRPC_HEADER(rpcname, reqstruct, rplystruct) \</td></tr>
      <tr><td class="left">EVRPC_STRUCT(rpcname) {        \</td><td> </td><td class="right">EVRPC_STRUCT(rpcname) {        \</td></tr>
      <tr><td class="left">       struct evrpc_hook_meta *hook_meta; \</td><td> </td><td class="right">       struct evrpc_hook_meta *hook_meta; \</td></tr>
      <tr><td class="left">       struct reqstruct* request; \</td><td> </td><td class="right">       struct reqstruct* request; \</td></tr>
      <tr><td class="left">       struct rplystruct* reply; \</td><td> </td><td class="right">       struct rplystruct* reply; \</td></tr>
      <tr><td class="left">       struct evrpc* rpc; \</td><td> </td><td class="right">       struct evrpc* rpc; \</td></tr>
      <tr><td class="left">       struct evhttp_request* http_req; \</td><td> </td><td class="right">       struct evhttp_request* http_req; \</td></tr>
      <tr><td class="left">       struct evbuffer* rpc_data; \</td><td> </td><td class="right">       struct evbuffer* rpc_data; \</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 211<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 211<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">       void (*cb)(struct evrpc_status *, void *, void *, void *),</td><td> </td><td class="right">       void (*cb)(struct evrpc_status *, void *, void *, void *),</td></tr>
      <tr><td class="left">       void *cbarg);</td><td> </td><td class="right">       void *cbarg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Creates a context structure that contains rpc specific information.</td><td> </td><td class="right">/** Creates a context structure that contains rpc specific information.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * EVRPC_MAKE_CTX is used to populate a RPC specific context that</td><td> </td><td class="right"> * EVRPC_MAKE_CTX is used to populate a RPC specific context that</td></tr>
      <tr><td class="left"> * contains information about marshaling the RPC data types.</td><td> </td><td class="right"> * contains information about marshaling the RPC data types.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param rpcname the name of the RPC</td><td> </td><td class="right"> * @param rpcname the name of the RPC</td></tr>
      <tr><td class="left"> * @param reqstruct the name of the RPC request structure</td><td> </td><td class="right"> * @param reqstruct the name of the RPC request structure</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"> * @param r<span class="delete">e</span>plystruct the name of the RPC reply structure</td><td> </td><td class="rblock"> * @param rplystruct the name of the RPC reply structure</td></tr>
      <tr><td class="left"> * @param pool the evrpc_pool over which to make the request</td><td> </td><td class="right"> * @param pool the evrpc_pool over which to make the request</td></tr>
      <tr><td class="left"> * @param request a pointer to the RPC request structure object</td><td> </td><td class="right"> * @param request a pointer to the RPC request structure object</td></tr>
      <tr><td class="left"> * @param reply a pointer to the RPC reply structure object</td><td> </td><td class="right"> * @param reply a pointer to the RPC reply structure object</td></tr>
      <tr><td class="left"> * @param cb the callback function to call when the RPC has completed</td><td> </td><td class="right"> * @param cb the callback function to call when the RPC has completed</td></tr>
      <tr><td class="left"> * @param cbarg the argument to supply to the callback</td><td> </td><td class="right"> * @param cbarg the argument to supply to the callback</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVRPC_MAKE_CTX(rpcname, reqstruct, rplystruct, \</td><td> </td><td class="right">#define EVRPC_MAKE_CTX(rpcname, reqstruct, rplystruct, \</td></tr>
      <tr><td class="left">    pool, request, reply, cb, cbarg)                                   \</td><td> </td><td class="right">    pool, request, reply, cb, cbarg)                                   \</td></tr>
      <tr><td class="left">       evrpc_make_request_ctx(pool, request, reply,                    \</td><td> </td><td class="right">       evrpc_make_request_ctx(pool, request, reply,                    \</td></tr>
      <tr><td class="left">           #rpcname,                                                   \</td><td> </td><td class="right">           #rpcname,                                                   \</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 235<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 235<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">           (void (*)(struct evrpc_status *, void *, void *, void *))cb, \</td><td> </td><td class="right">           (void (*)(struct evrpc_status *, void *, void *, void *))cb, \</td></tr>
      <tr><td class="left">           cbarg)</td><td> </td><td class="right">           cbarg)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Generates the code for receiving and sending an RPC message</td><td> </td><td class="right">/** Generates the code for receiving and sending an RPC message</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * EVRPC_GENERATE is used to create the code corresponding to sending</td><td> </td><td class="right"> * EVRPC_GENERATE is used to create the code corresponding to sending</td></tr>
      <tr><td class="left"> * and receiving a particular RPC message</td><td> </td><td class="right"> * and receiving a particular RPC message</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param rpcname the name of the RPC</td><td> </td><td class="right"> * @param rpcname the name of the RPC</td></tr>
      <tr><td class="left"> * @param reqstruct the name of the RPC request structure</td><td> </td><td class="right"> * @param reqstruct the name of the RPC request structure</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"> * @param r<span class="delete">e</span>plystruct the name of the RPC reply structure</td><td> </td><td class="rblock"> * @param rplystruct the name of the RPC reply structure</td></tr>
      <tr><td class="left"> * @see EVRPC_HEADER()</td><td> </td><td class="right"> * @see EVRPC_HEADER()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVRPC_GENERATE(rpcname, reqstruct, rplystruct)                 \</td><td> </td><td class="right">#define EVRPC_GENERATE(rpcname, reqstruct, rplystruct)                 \</td></tr>
      <tr><td class="left">       int evrpc_send_request_##rpcname(struct evrpc_pool *pool,       \</td><td> </td><td class="right">       int evrpc_send_request_##rpcname(struct evrpc_pool *pool,       \</td></tr>
      <tr><td class="left">           struct reqstruct *request, struct rplystruct *reply,        \</td><td> </td><td class="right">           struct reqstruct *request, struct rplystruct *reply,        \</td></tr>
      <tr><td class="left">           void (*cb)(struct evrpc_status *,                           \</td><td> </td><td class="right">           void (*cb)(struct evrpc_status *,                           \</td></tr>
      <tr><td class="left">               struct reqstruct *, struct rplystruct *, void *cbarg),  \</td><td> </td><td class="right">               struct reqstruct *, struct rplystruct *, void *cbarg),  \</td></tr>
      <tr><td class="left">           void *cbarg) {                                              \</td><td> </td><td class="right">           void *cbarg) {                                              \</td></tr>
      <tr><td class="left">       return evrpc_send_request_generic(pool, request, reply, \</td><td> </td><td class="right">       return evrpc_send_request_generic(pool, request, reply, \</td></tr>
      <tr><td class="left">           (void (*)(struct evrpc_status *, void *, void *, void *))cb, \</td><td> </td><td class="right">           (void (*)(struct evrpc_status *, void *, void *, void *))cb, \</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 5 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>5 lines changed or deleted</i></th><th><i> </i></th><th><i>5 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;rpc_compat.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;rpc_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_RPC_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_RPC_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_RPC_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_RPC_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/rpc_compat.h</td><td> </td><td class="right">/** @file event2/rpc_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Deprecated versions of the functions in rpc.h: provided only for</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Deprecated versions of the functions in rpc.h: provided only for</td></tr>
      <tr><td class="left">  backwards compatibility.</td><td> </td><td class="right">  backwards compatibility.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** backwards compatible accessors that work only with gcc */</td><td> </td><td class="right">/** backwards compatible accessors that work only with gcc */</td></tr>
      <tr><td class="left">#if defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__)</td><td> </td><td class="right">#if defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__)</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;tag.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;tag.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_TAG_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_TAG_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_TAG_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_TAG_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/tag.h</td><td> </td><td class="right">/** @file event2/tag.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Helper functions for reading and writing tagged data onto buffers.</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Helper functions for reading and writing tagged data onto buffers.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;tag_compat.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;tag_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_TAG_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_TAG_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_TAG_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_TAG_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/tag_compat.h</td><td> </td><td class="right">/** @file event2/tag_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">    <span class="delete">Obsolete/deprecated functions from tag.h; provided only for back</span>wards</td><td> </td><td class="rblock">    <span class="insert">@brief Obsolete/deprecated functions from tag.h; provided only for back
</span>wards</td></tr>
      <tr><td class="left">    compatibility.</td><td> </td><td class="right">    compatibility.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   @name Misnamed functions</td><td> </td><td class="right">   @name Misnamed functions</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @deprecated These macros are deprecated because their names don't follow</td><td> </td><td class="right">   @deprecated These macros are deprecated because their names don't follow</td></tr>
      <tr><td class="left">     Libevent's naming conventions.  Use evtag_encode_int and</td><td> </td><td class="right">     Libevent's naming conventions.  Use evtag_encode_int and</td></tr>
      <tr><td class="left">     evtag_encode_int64 instead.</td><td> </td><td class="right">     evtag_encode_int64 instead.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;thread.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;thread.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_THREAD_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_THREAD_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_THREAD_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_THREAD_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/thread.h</td><td> </td><td class="right">/** @file event2/thread.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Functions for multi-threaded applications using Libevent.</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Functions for multi-threaded applications using Libevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  When using a multi-threaded application in which multiple threads</td><td> </td><td class="right">  When using a multi-threaded application in which multiple threads</td></tr>
      <tr><td class="left">  add and delete events from a single event base, Libevent needs to</td><td> </td><td class="right">  add and delete events from a single event base, Libevent needs to</td></tr>
      <tr><td class="left">  lock its data structures.</td><td> </td><td class="right">  lock its data structures.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Like the memory-management function hooks, all of the threading functions</td><td> </td><td class="right">  Like the memory-management function hooks, all of the threading functions</td></tr>
      <tr><td class="left">  _must_ be set up before an event_base is created if you want the base to</td><td> </td><td class="right">  _must_ be set up before an event_base is created if you want the base to</td></tr>
      <tr><td class="left">  use them.</td><td> </td><td class="right">  use them.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Most programs will either be using Windows threads or Posix threads.  You</td><td> </td><td class="right">  Most programs will either be using Windows threads or Posix threads.  You</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 187<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 187<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * probably shouldn't call this function; instead, use</td><td> </td><td class="right"> * probably shouldn't call this function; instead, use</td></tr>
      <tr><td class="left"> * evthread_use_windows_threads() or evthread_use_pthreads() if you can.</td><td> </td><td class="right"> * evthread_use_windows_threads() or evthread_use_pthreads() if you can.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evthread_set_condition_callbacks(</td><td> </td><td class="right">int evthread_set_condition_callbacks(</td></tr>
      <tr><td class="left">       const struct evthread_condition_callbacks *);</td><td> </td><td class="right">       const struct evthread_condition_callbacks *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Sets the function for determining the thread id.</td><td> </td><td class="right">   Sets the function for determining the thread id.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"><span class="delete">   @param base the event base for which to set the id function</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">   @param id_fn the identify function Libevent should invoke to</td><td> </td><td class="right">   @param id_fn the identify function Libevent should invoke to</td></tr>
      <tr><td class="left">     determine the identity of a thread.</td><td> </td><td class="right">     determine the identity of a thread.</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evthread_set_id_callback(</td><td> </td><td class="right">void evthread_set_id_callback(</td></tr>
      <tr><td class="left">    unsigned long (*id_fn)(void));</td><td> </td><td class="right">    unsigned long (*id_fn)(void));</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#if (defined(_WIN32) &amp;&amp; !defined(EVENT__DISABLE_THREAD_SUPPORT)) || defined
(EVENT_IN_DOXYGEN_)</td><td> </td><td class="right">#if (defined(_WIN32) &amp;&amp; !defined(EVENT__DISABLE_THREAD_SUPPORT)) || defined
(EVENT_IN_DOXYGEN_)</td></tr>
      <tr><td class="left">/** Sets up Libevent for use with Windows builtin locking and thread ID</td><td> </td><td class="right">/** Sets up Libevent for use with Windows builtin locking and thread ID</td></tr>
      <tr><td class="left">    functions.  Unavailable if Libevent is not built for Windows.</td><td> </td><td class="right">    functions.  Unavailable if Libevent is not built for Windows.</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 2 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;util.h (2.1.11)&nbsp;</th><th> </th><th>&nbsp;util.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_UTIL_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_UTIL_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_UTIL_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_UTIL_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/util.h</td><td> </td><td class="right">/** @file event2/util.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Common convenience functions for cross-platform portability and</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Common convenience functions for cross-platform portability and</td></tr>
      <tr><td class="left">  related socket manipulations.</td><td> </td><td class="right">  related socket manipulations.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><div style='width:100%;' align='left' class='small'>This html diff was produced by rfcdiff 1.41.The latest version is available from <a href='http://tools.ietf.org/tools/rfcdiff/'>http://tools.ietf.org/tools/rfcdiff/</a></div>
</td></tr></table>
</body>
</html>
